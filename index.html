<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantabet Amici - Sistema Scommesse Fantacalcio</title>
    
    <!-- Icone per iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    
    <!-- Icona per Android e altri dispositivi -->
    <link rel="icon" type="image/png" sizes="192x192" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    <link rel="icon" type="image/png" sizes="512x512" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    
    <!-- Favicon standard -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png">
    
    <!-- Meta tag per Web App -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FantaBet">
    <meta name="theme-color" content="#0a1628">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #0a1628; 
            color: #e0e7ff;
            background-image: url('https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/Stadium.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
        }
        
        /* Overlay blu per migliorare la leggibilit√† */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.25);
            z-index: -1;
        }
        
        .card { background-color: rgba(15, 23, 42, 0.95); border-radius: 12px; border: 1px solid #1e3a8a; padding: 16px; box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2); backdrop-filter: blur(10px); }
        
        /* Responsive padding for cards */
        @media (min-width: 768px) {
            .card { padding: 24px; }
        }
        
        /* Pulsanti ottimizzati per mobile con minimo 44x44px (Apple HIG) */
        .btn-primary { 
            background-color: #2563eb; 
            color: white; 
            padding: 14px 20px; 
            border-radius: 8px; 
            font-weight: 600; 
            font-size: 16px;
            min-height: 44px;
            transition: background-color 0.2s; 
            cursor: pointer;
            touch-action: manipulation;
        }
        .btn-primary:hover { background-color: #1d4ed8; }
        
        .btn-secondary { 
            background-color: #1e3a8a; 
            color: #e0e7ff; 
            padding: 14px 20px; 
            border-radius: 8px; 
            font-weight: 600; 
            font-size: 16px;
            min-height: 44px;
            transition: background-color 0.2s; 
            cursor: pointer;
            touch-action: manipulation;
        }
        .btn-secondary:hover { background-color: #1e40af; }
        
        .btn-danger { 
            background-color: #dc2626; 
            color: white; 
            padding: 14px 20px; 
            border-radius: 8px; 
            font-weight: 600; 
            font-size: 16px;
            min-height: 44px;
            transition: background-color 0.2s; 
            cursor: pointer;
            touch-action: manipulation;
        }
        .btn-danger:hover { background-color: #b91c1c; }
        
        .btn-success { 
            background-color: #10b981; 
            color: white; 
            padding: 14px 20px; 
            border-radius: 8px; 
            font-weight: 600; 
            font-size: 16px;
            min-height: 44px;
            transition: background-color 0.2s; 
            cursor: pointer;
            touch-action: manipulation;
        }
        .btn-success:hover { background-color: #059669; }
        
        /* Input ottimizzati per mobile */
        input[type="number"], input[type="text"], input[type="email"], input[type="password"], select, input[type="date"] {
            background-color: #0f172a;
            border: 1px solid #1e3a8a;
            color: #e0e7ff;
            padding: 12px;
            border-radius: 6px;
            width: 100%;
            font-size: 16px; /* Previene zoom automatico su iOS */
            min-height: 44px;
        }
        .bet-option {
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            background-color: #1e293b;
            padding: 14px;
            min-height: 50px;
            font-size: 15px;
            touch-action: manipulation;
        }
        
        @media (min-width: 768px) {
            .bet-option {
                padding: 12px;
                font-size: 14px;
            }
        }
        .bet-option:hover:not(.pointer-events-none) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(37, 99, 235, 0.4);
            border-color: #3b82f6;
        }
        .bet-option.pointer-events-none {
            pointer-events: none;
            cursor: not-allowed;
        }
        .bet-option.opacity-50 {
            opacity: 0.5;
        }
        /* Stile per indicare la selezione attiva (prediction locale) */
        .bet-option.local-selected {
            border-color: #3b82f6;
            background-color: #1e3a8a; 
            box-shadow: 0 0 10px #3b82f6;
        }
        /* Stile per indicare una scommessa SALVATA in Firestore */
        .bet-option.saved-bet {
            border-color: #2563eb;
            background-color: #1e40af;
            box-shadow: 0 0 10px #2563eb;
        }
        
        /* Stili per il countdown animato */
        @keyframes pulse-countdown {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .countdown-urgent {
            animation: pulse-countdown 2s ease-in-out infinite;
        }
        
        /* Stile specifico per l'intestazione della giornata */
        .giornata-header th {
            padding: 8px 12px;
            text-align: left;
            font-size: 0.875rem;
            color: #60a5fa;
            border-bottom: 2px solid #1e3a8a;
        }
        
        @media (min-width: 768px) {
            .giornata-header th {
                padding: 12px 16px;
                font-size: 1rem;
            }
        }
        
        /* Ottimizzazione tabelle per mobile */
        table {
            font-size: 0.875rem;
        }
        
        @media (min-width: 768px) {
            table {
                font-size: 1rem;
            }
        }
        
        table th, table td {
            padding: 8px 6px;
            white-space: nowrap;
        }
        
        @media (min-width: 768px) {
            table th, table td {
                padding: 12px 16px;
            }
        }

        /* Stile per la modale di conferma */
        .confirm-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 22, 40, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            padding: 16px;
        }
        .confirm-modal-content {
            background-color: #0f172a;
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 20px rgba(37, 99, 235, 0.3);
            border: 1px solid #1e3a8a;
            text-align: center;
        }
        
        @media (min-width: 768px) {
            .confirm-modal-content {
                padding: 24px;
            }
        }
        
        /* Modifica per centrare i messaggi di notifica */
        #message-box {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 22, 40, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            padding: 16px;
        }
        #message-box:not(.hidden) {
            display: flex;
        }
        
        /* Progress bar container */
        #progress-bar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 22, 40, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            padding: 16px;
        }
        
        #progress-bar-container:not(.hidden) {
            display: flex;
        }
        
        /* Menu utente mobile */
        #user-menu-toggle {
            transition: transform 0.2s;
        }
        
        #user-menu-dropdown {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, visibility 0.3s;
        }
        
        #user-menu-dropdown.open {
            max-height: 400px;
            opacity: 1;
            visibility: visible;
        }
        
        /* === EFFETTI HALLOWEEN === */
        #halloween-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 1s ease-out;
        }
        
        #halloween-overlay.active {
            opacity: 1;
        }
        
        .spider {
            position: absolute;
            font-size: 24px;
            animation: spider-walk 8s linear;
        }
        
        @keyframes spider-walk {
            0% {
                top: -50px;
                transform: rotate(0deg);
            }
            50% {
                transform: rotate(180deg);
            }
            100% {
                top: 100vh;
                transform: rotate(360deg);
            }
        }
        
        .bat {
            position: absolute;
            font-size: 28px;
            animation: bat-fly 6s ease-in-out;
        }
        
        @keyframes bat-fly {
            0% {
                left: -50px;
                top: 20%;
                transform: scale(1) rotate(0deg);
            }
            25% {
                top: 40%;
                transform: scale(1.2) rotate(10deg);
            }
            50% {
                top: 30%;
                transform: scale(1) rotate(-10deg);
            }
            75% {
                top: 50%;
                transform: scale(1.2) rotate(5deg);
            }
            100% {
                left: 110%;
                top: 35%;
                transform: scale(1) rotate(0deg);
            }
        }
        
        .web {
            position: absolute;
            width: 150px;
            height: 150px;
            opacity: 0.6;
        }
        
        .web-corner {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }
        
        .web-corner.top-left {
            top: 0;
            left: 0;
            border-width: 100px 100px 0 0;
            border-color: rgba(200, 200, 200, 0.3) transparent transparent transparent;
        }
        
        .web-corner.top-right {
            top: 0;
            right: 0;
            border-width: 0 100px 100px 0;
            border-color: transparent rgba(200, 200, 200, 0.3) transparent transparent;
        }
        
        @keyframes fade-out {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
    
    <script>
        // Funzione per il menu utente - definita prima del body
        function toggleUserMenu() {
            const dropdown = document.getElementById('user-menu-dropdown');
            const button = document.getElementById('user-menu-toggle');
            
            if (dropdown && button) {
                if (dropdown.classList.contains('open')) {
                    dropdown.classList.remove('open');
                    button.style.transform = 'rotate(0deg)';
                } else {
                    dropdown.classList.add('open');
                    button.style.transform = 'rotate(90deg)';
                }
            }
        }
        
        // Chiudi il menu quando si clicca fuori - si attiva dopo il caricamento del DOM
        document.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('click', (event) => {
                const dropdown = document.getElementById('user-menu-dropdown');
                const button = document.getElementById('user-menu-toggle');
                
                if (dropdown && button && !dropdown.contains(event.target) && !button.contains(event.target)) {
                    dropdown.classList.remove('open');
                    button.style.transform = 'rotate(0deg)';
                }
            });
        });
    </script>

</head>
<body class="min-h-screen p-3 sm:p-6 md:p-8">

    <!-- Effetto Halloween (30 ott - 2 nov 2025) -->
    <div id="halloween-overlay"></div>

    <!-- Menu utente compatto -->
    <div class="fixed top-2 right-2 z-50">
        <!-- Pulsante menu hamburger -->
        <button id="user-menu-toggle" onclick="toggleUserMenu()" class="bg-gray-900/90 backdrop-blur-sm border border-blue-500/50 rounded-lg p-2 sm:p-3 shadow-lg hover:bg-gray-800 transition-all">
            <svg class="w-6 h-6 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
            </svg>
        </button>
        
        <!-- Dropdown menu -->
        <div id="user-menu-dropdown" class="absolute top-14 right-0 bg-gray-900/95 backdrop-blur-sm border border-blue-500/50 rounded-lg shadow-xl overflow-hidden min-w-[250px]">
            <div class="p-4 space-y-3">
                <div id="auth-status" class="text-xs text-green-400 text-center pb-2 border-b border-gray-700">Caricamento...</div>
                
                <div class="space-y-2">
                    <div id="user-display-name" class="text-sm text-gray-300 font-semibold"></div>
                    <div id="user-id-display" class="text-xs text-gray-500"></div>
                </div>
                
                <div class="flex flex-col space-y-2 pt-2 border-t border-gray-700">
                    <div id="user-credits-display" class="px-3 py-2 bg-yellow-900/50 rounded-lg text-yellow-300 font-bold text-sm text-center border border-yellow-700/50">
                        Crediti: 100
                    </div>
                    <div id="user-role-display" class="px-3 py-2 bg-blue-900/50 rounded-lg text-blue-300 font-bold text-sm text-center border border-blue-700/50"></div>
                </div>
                
                <button id="logout-button" onclick="handleLogout()" class="w-full btn-danger text-sm py-2 hidden mt-3">
                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                    </svg>
                    Logout
                </button>
            </div>
        </div>
    </div>
    
    <div class="max-w-6xl mx-auto">
        <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold mb-4 sm:mb-6 md:mb-8 text-center text-green-400">
            FantaBet
        </h1>
        <p class="text-center mb-10 text-gray-400">Gioca e scommetti sulle partite della lega fantacalcio Orecchiette e Prosciutto</p>

        <!-- Sezione Login (mostrata se non autenticato) -->
        <div id="login-container" class="max-w-md mx-auto card p-6 sm:p-8 hidden">
            <h2 id="auth-title" class="text-xl sm:text-2xl font-semibold mb-4 sm:mb-6 text-center">Accedi a FantaBet</h2>
            <div class="space-y-4">
                <div class="flex flex-col">
                    <label for="auth-email" class="text-sm sm:text-base text-gray-400 mb-1">Email</label>
                    <input type="email" id="auth-email" placeholder="Inserisci la tua email" required>
                </div>
                <div class="flex flex-col">
                    <label for="auth-password" class="text-sm sm:text-base text-gray-400 mb-1">Password</label>
                    <input type="password" id="auth-password" placeholder="Inserisci la tua password" required>
                </div>
            </div>
            <div class="mt-6 flex flex-col space-y-3">
                <button onclick="handleLoginRegister(true)" class="btn-primary w-full" id="login-button-ui">Accedi</button>
                <button onclick="handleLoginRegister(false)" class="btn-secondary w-full" id="register-button-ui">Registrati</button>
            </div>
        </div>
        
        <!-- Contenitore App Principale (Nascosto finch√© non autenticato) -->
           <!-- Modale di Conferma Cancellazione -->
            <div id="confirm-modal" class="confirm-modal hidden">
                <div class="confirm-modal-content">
                    <p id="confirm-text" class="text-base sm:text-lg mb-4 sm:mb-6 font-semibold text-red-400">Sei sicuro di voler cancellare TUTTI i dati storici, squadre, partite e scommesse? Questa azione √® irreversibile.</p>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button onclick="document.getElementById('confirm-modal').classList.add('hidden');" class="btn-secondary w-full sm:w-auto">Annulla</button>
                        <button onclick="clearHistoricResultsAndTeams(true)" class="btn-danger w-full sm:w-auto">Conferma Cancellazione Totale</button>
                    </div>
                </div>
            </div>
        <div id="main-app-container" class="hidden">
            <!-- Sezione Messaggi (Modale) - CENTRATO -->
            <div id="message-box" class="hidden">
                <div class="card p-4 sm:p-6 w-11/12 sm:w-96 max-w-md text-center">
                    <p id="message-text" class="text-base sm:text-lg mb-4"></p>
                    <button onclick="hideMessageBox()" class="btn-primary w-full sm:w-auto">OK</button>
                </div>
            </div>

            <!-- Barra di Progresso -->
            <div id="progress-bar-container" class="hidden">
                <div class="card p-4 sm:p-6 w-11/12 sm:w-96 max-w-md">
                    <h3 id="progress-title" class="text-base sm:text-lg font-bold mb-4 text-center">Elaborazione in corso...</h3>
                    <div class="mb-2">
                        <div class="w-full bg-gray-700 rounded-full h-8 sm:h-6 overflow-hidden">
                            <div id="progress-bar-fill" class="bg-blue-500 h-8 sm:h-6 transition-all duration-300 flex items-center justify-center text-white text-sm font-bold" style="width: 0%">
                                <span id="progress-percentage">0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="text-center text-sm text-gray-400 space-y-1">
                        <div id="progress-status">Inizializzazione...</div>
                        <div id="progress-time" class="text-xs"></div>
                    </div>
                </div>
            </div>

            
            <!-- CONTENITORE PRINCIPALE MODALIT√Ä: ADMIN / SCOMMESSE / HOME -->
            <div id="app-content-area">
                
                <!-- HOME DASHBOARD (Visibile dopo il login) -->
                <div id="home-container" class="max-w-4xl mx-auto space-y-4 sm:space-y-6">
                    <div class="card p-4 sm:p-6 md:p-8 text-center space-y-4 sm:space-y-6">
                        <!-- Logo della Lega -->
                        <div class="flex justify-center mb-4 sm:mb-6">
                            <img src="https://raw.githubusercontent.com/savinopi/FantaBet-OP/main/esempio%20stemma%20lega.png" alt="Logo Fantabet" class="w-24 h-24 sm:w-32 sm:h-32 object-contain" onerror="this.style.display='none'">
                        </div>
                        
                        <h2 class="text-xl sm:text-2xl md:text-3xl font-bold mb-3 sm:mb-4">Benvenuto Ludopatico! Scegli la tua area.</h2>

                        <div class="space-y-3 sm:space-y-4">
                            <button onclick="setAppView('betting')" class="w-full py-4 sm:py-5 text-lg sm:text-xl btn-primary shadow-lg">
                                <svg class="w-5 h-5 sm:w-6 sm:h-6 inline mr-2" fill="currentColor" viewBox="0 0 512 512">
                                    <path d="M177.1 228.6L207.9 320h96.5l29.62-91.38L256 172.1L177.1 228.6zM255.1 0C114.6 0 .0001 114.6 .0001 256S114.6 512 256 512s255.1-114.6 255.1-255.1S397.4 0 255.1 0zM416.6 246.8L381.9 214l-22.44 62.32l-22.62 7.816l22.38-61.97l-34.71-32.81l34.71-32.81l-22.38-61.97l22.62 7.816L381.9 166.7l34.71-32.81c-34.46-37.46-81.03-63.03-134.5-69.58l-8.066 75.92l-22.44 7.891L260.1 90.16L273.7 13.36C268.5 13.12 263.3 12.1 258.1 12.1c-6.047 0-11.1 .4766-17.83 .8906l12.36 76.83l8.531 58.02L238.7 139.8l-7.844-75.15C176.4 71.23 129.8 96.8 95.35 134.2l34.71 32.81l-22.38 61.97l22.62-7.816L152.7 166.7l34.71 32.81l-34.71 32.81l22.38 61.97l-22.62-7.816L130.1 214L95.35 246.8C108.7 283.9 134.2 314.3 168.8 334.7l7.775-75.43l22.38-7.922l-8.119 58.18l-12.49 76.62c5.453 .2969 10.86 .875 16.51 .875c6.203 0 12.31-.5781 18.43-1.016l-12.76-77.83l-8.205-58.29l22.46 8.012l7.559 75.75c54.25-6.549 101.6-32.45 136.1-69.91L324.2 231.8l22.38-61.97L323.9 177.7L301.5 214L266.8 246.8l34.71 32.81l22.38 61.97l-22.62-7.816l-7.504-75.11l-22.5-8.066l8.131 58.44l12.69 77.74c54.84-6.699 102.4-32.87 137.1-70.55L416.6 246.8z"/>
                                </svg>
                                Vai a Scommesse
                            </button>

                            <!-- Bottone Admin (invisibile per default, checkAdminStatus ne gestisce la visibilit√†) -->
                            <button id="admin-button-home" onclick="setAppView('admin')" class="w-full py-4 text-base sm:text-lg btn-secondary hidden">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
                                </svg>
                                Area Admin
                            </button>

                            <!-- Profilo utente -->
                            <button onclick="setAppView('profile')" class="w-full py-4 text-base sm:text-lg btn-secondary">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"></path>
                                </svg>
                                Profilo
                            </button>

                            <!-- Mostra i risultati storici -->
                            <button onclick="setAppView('historic_results')" class="w-full py-4 text-base sm:text-lg btn-secondary">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
                                    <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
                                </svg>
                                Risultati Storici
                            </button>

                            <!-- Mostra le Rose -->
                            <button onclick="setAppView('squads')" class="w-full py-4 text-base sm:text-lg btn-secondary">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"></path>
                                </svg>
                                Rose
                            </button>

                            <!-- Mostra Statistiche Calciatori -->
                            <button onclick="setAppView('player_stats')" class="w-full py-4 text-base sm:text-lg btn-secondary">
                                <svg class="w-4 h-4 sm:w-5 sm:h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"></path>
                                </svg>
                                Statistiche Calciatori
                            </button>
                        </div>
                    </div>
                    
                    <!-- Classifica -->
                    <div class="card p-4 sm:p-6">
                        <h3 class="text-xl sm:text-2xl font-bold mb-3 sm:mb-4 text-yellow-500 flex items-center">
                            <svg class="w-6 h-6 sm:w-8 sm:h-8 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
                                <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
                            </svg>
                            Classifica
                        </h3>
                        <div id="standings-container" class="overflow-x-auto -mx-4 sm:mx-0">
                            <p class="text-sm sm:text-base text-gray-500 text-center py-4">Carica i risultati per visualizzare la classifica</p>
                        </div>
                    </div>
                    
                    <!-- Statistiche Lega -->
                    <div class="card p-4 sm:p-6">
                        <h3 class="text-xl sm:text-2xl font-bold mb-3 sm:mb-4 text-purple-500 flex items-center">
                            <svg class="w-6 h-6 sm:w-8 sm:h-8 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"></path>
                            </svg>
                            Statistiche Lega
                        </h3>
                        <div id="statistics-container" class="grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                            <p class="text-sm sm:text-base text-gray-500 text-center py-4 col-span-full">Carica i risultati per visualizzare le statistiche</p>
                        </div>
                    </div>
                    
                    <!-- Statistiche Calciatori -->
                    <div class="card p-4 sm:p-6">
                        <h3 class="text-xl sm:text-2xl font-bold mb-3 sm:mb-4 text-blue-500 flex items-center">
                            <svg class="w-6 h-6 sm:w-8 sm:h-8 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"></path>
                            </svg>
                            Statistiche Calciatori
                        </h3>
                        <div id="player-statistics-container" class="grid grid-cols-1 md:grid-cols-2 gap-3 sm:gap-4">
                            <p class="text-sm sm:text-base text-gray-500 text-center py-4 col-span-full">Carica le statistiche calciatori per visualizzare le classifiche</p>
                        </div>
                    </div>
                    
                    <!-- Andamento Classifica -->
                    <div class="card p-4 sm:p-6">
                        <h3 class="text-xl sm:text-2xl font-bold mb-3 sm:mb-4 text-orange-500 flex items-center">
                            <svg class="w-6 h-6 sm:w-8 sm:h-8 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11.707 4.707a1 1 0 00-1.414-1.414L10 9.586 8.707 8.293a1 1 0 00-1.414 0l-2 2a1 1 0 101.414 1.414L8 10.414l1.293 1.293a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            Andamento Classifica
                        </h3>
                        <div id="standings-trend-container" class="relative" style="min-height: 400px;">
                            <canvas id="standings-trend-chart"></canvas>
                            <p id="standings-trend-placeholder" class="text-sm sm:text-base text-gray-500 text-center py-4 absolute inset-0 flex items-center justify-center">Carica i risultati per visualizzare l'andamento della classifica</p>
                        </div>
                    </div>
                </div>

                <!-- RISULTATI STORICI come SIBLING della HOME (prima era annidato dentro home --> 
                <div id="historic-results-container" class="max-w-6xl mx-auto card p-4 sm:p-6 hidden">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 space-y-3 sm:space-y-0">
                        <h2 class="text-xl sm:text-2xl font-semibold flex items-center">
                            <svg class="w-5 h-5 sm:w-6 sm:h-6 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"></path>
                                <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd"></path>
                            </svg>
                            Risultati Storici
                        </h2>
                        <div class="flex space-x-2 w-full sm:w-auto">
                            <button onclick="setAppView('home')" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                                </svg>
                                Home
                            </button>
                            <button onclick="setAppView(currentView)" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Aggiorna
                            </button>
                        </div>
                    </div>
                    <div class="mb-4">
                        <label for="historic-date" class="block text-sm font-medium text-gray-300 mb-2">Seleziona una data:</label>
                        <input type="date" id="historic-date" class="w-full" onchange="loadHistoricResults()">
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full bg-gray-800 rounded-lg overflow-hidden">
                            <thead>
                                <tr class="bg-gray-700 text-gray-400">
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Giornata</th>
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Data</th>
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Squadra Casa</th>
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Squadra Ospite</th>
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Risultato</th>
                                    <th class="px-6 py-3 text-left whitespace-nowrap">Punteggio</th>
                                </tr>
                            </thead>
                            <tbody id="historic-results-table" class="text-gray-300">
                                <!-- I risultati storici verranno inseriti qui tramite JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- SEZIONE ROSE - Visualizzazione rose delle squadre -->
                <div id="squads-container" class="max-w-6xl mx-auto card p-4 sm:p-6 hidden">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 space-y-3 sm:space-y-0">
                        <h2 class="text-xl sm:text-2xl font-semibold flex items-center">
                            <svg class="w-5 h-5 sm:w-6 sm:h-6 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"></path>
                            </svg>
                            Rose delle Squadre
                        </h2>
                        <div class="flex space-x-2 w-full sm:w-auto">
                            <button onclick="setAppView('home')" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                                </svg>
                                Home
                            </button>
                            <button onclick="loadSquadsData()" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Aggiorna
                            </button>
                        </div>
                    </div>
                    
                    <!-- Filtro squadra -->
                    <div class="mb-4">
                        <label for="squad-filter" class="block text-sm font-medium text-gray-300 mb-2">Filtra per squadra:</label>
                        <select id="squad-filter" class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 text-white" onchange="filterSquadView()">
                            <option value="all">Tutte le squadre</option>
                        </select>
                    </div>
                    
                    <!-- Container per le rose -->
                    <div id="squads-view-container">
                        <p class="text-sm sm:text-base text-gray-500 text-center py-4">Caricamento rose in corso...</p>
                    </div>
                </div>

                <!-- SEZIONE STATISTICHE CALCIATORI - Visualizzazione statistiche -->
                <div id="player-stats-container" class="max-w-7xl mx-auto card p-4 sm:p-6 hidden">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 space-y-3 sm:space-y-0">
                        <h2 class="text-xl sm:text-2xl font-semibold flex items-center">
                            <svg class="w-5 h-5 sm:w-6 sm:h-6 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z"></path>
                            </svg>
                            Statistiche Calciatori
                        </h2>
                        <div class="flex space-x-2 w-full sm:w-auto">
                            <button onclick="setAppView('home')" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                                </svg>
                                Home
                            </button>
                            <button onclick="loadPlayerStats()" class="btn-secondary flex-1 sm:flex-none px-3 py-2">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Aggiorna
                            </button>
                        </div>
                    </div>
                    
                    <!-- Filtri -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
                        <div>
                            <label for="stats-squad-filter" class="block text-sm font-medium text-gray-300 mb-2">Rosa:</label>
                            <select id="stats-squad-filter" class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 text-white" onchange="filterPlayerStats()">
                                <option value="all">Tutte le rose</option>
                            </select>
                        </div>
                        <div>
                            <label for="stats-role-filter" class="block text-sm font-medium text-gray-300 mb-2">Ruolo:</label>
                            <select id="stats-role-filter" class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 text-white" onchange="filterPlayerStats()">
                                <option value="all">Tutti</option>
                                <option value="P">Portieri</option>
                                <option value="D">Difensori</option>
                                <option value="C">Centrocampisti</option>
                                <option value="A">Attaccanti</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Legenda ordinamento -->
                    <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg px-4 py-2 mb-4">
                        <p class="text-xs sm:text-sm text-blue-300">
                            <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                            </svg>
                            Clicca su un'intestazione della tabella per ordinare
                        </p>
                    </div>
                    
                    <!-- Container statistiche -->
                    <div id="player-stats-view-container">
                        <p class="text-sm sm:text-base text-gray-500 text-center py-4">Caricamento statistiche in corso...</p>
                    </div>
                </div>

                <!-- Placeholder per le aree usate dallo script (invisibili finch√© non richieste) -->
                <div id="betting-area" class="hidden max-w-4xl mx-auto card p-6">
                    <!-- Header con pulsante Home -->
                    <div class="flex justify-between items-center mb-4 pb-4 border-b border-blue-800">
                        <h2 class="text-2xl font-bold text-blue-400 flex items-center">
                            <svg class="w-7 h-7 mr-2" fill="currentColor" viewBox="0 0 512 512">
                                <path d="M177.1 228.6L207.9 320h96.5l29.62-91.38L256 172.1L177.1 228.6zM255.1 0C114.6 0 .0001 114.6 .0001 256S114.6 512 256 512s255.1-114.6 255.1-255.1S397.4 0 255.1 0zM416.6 246.8L381.9 214l-22.44 62.32l-22.62 7.816l22.38-61.97l-34.71-32.81l34.71-32.81l-22.38-61.97l22.62 7.816L381.9 166.7l34.71-32.81c-34.46-37.46-81.03-63.03-134.5-69.58l-8.066 75.92l-22.44 7.891L260.1 90.16L273.7 13.36C268.5 13.12 263.3 12.1 258.1 12.1c-6.047 0-11.1 .4766-17.83 .8906l12.36 76.83l8.531 58.02L238.7 139.8l-7.844-75.15C176.4 71.23 129.8 96.8 95.35 134.2l34.71 32.81l-22.38 61.97l22.62-7.816L152.7 166.7l34.71 32.81l-34.71 32.81l22.38 61.97l-22.62-7.816L130.1 214L95.35 246.8C108.7 283.9 134.2 314.3 168.8 334.7l7.775-75.43l22.38-7.922l-8.119 58.18l-12.49 76.62c5.453 .2969 10.86 .875 16.51 .875c6.203 0 12.31-.5781 18.43-1.016l-12.76-77.83l-8.205-58.29l22.46 8.012l7.559 75.75c54.25-6.549 101.6-32.45 136.1-69.91L324.2 231.8l22.38-61.97L323.9 177.7L301.5 214L266.8 246.8l34.71 32.81l22.38 61.97l-22.62-7.816l-7.504-75.11l-22.5-8.066l8.131 58.44l12.69 77.74c54.84-6.699 102.4-32.87 137.1-70.55L416.6 246.8z"/>
                            </svg>
                            Sezione Scommesse
                        </h2>
                        <button onclick="setAppView('home')" class="btn-secondary">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            Home
                        </button>
                    </div>
                    
                    <!-- Countdown Deadline Scommesse -->
                    <div id="bet-deadline-countdown" class="mb-4">
                        <!-- Renderizzato da JS -->
                    </div>
                    
                    <!-- Lista partite -->
                    <div id="open-matches-list" class="mb-6"></div>
                    <div id="no-open-matches" class="hidden text-center text-gray-400 py-4">
                        Nessuna partita aperta per le scommesse al momento.
                    </div>
                    
                    <!-- Form per la puntata (spostato sotto) -->
                    <div class="p-4 bg-gray-800 rounded-lg border-t-2 border-green-500">
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex-1 mr-4">
                                <label for="bet-stake-input" class="block text-sm font-medium text-gray-300 mb-2">
                                    Inserisci la puntata totale per la giornata:
                                </label>
                                <input type="number" 
                                       id="bet-stake-input" 
                                       min="1" 
                                       class="w-full bg-gray-700 text-white px-3 py-2 rounded" 
                                       placeholder="Inserisci crediti..." 
                                       oninput="updateGiornataBetButton()"
                                       aria-label="Puntata totale in crediti" />
                            </div>
                            <button id="place-giornata-bet-button" 
                                    onclick="placeBetForGiornata()" 
                                    class="btn-primary px-6 py-2 h-fit" 
                                    disabled>
                                <svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5 2a1 1 0 011 1v1h1a1 1 0 010 2H6v1a1 1 0 01-2 0V6H3a1 1 0 010-2h1V3a1 1 0 011-1zm0 10a1 1 0 011 1v1h1a1 1 0 110 2H6v1a1 1 0 11-2 0v-1H3a1 1 0 110-2h1v-1a1 1 0 011-1zM12 2a1 1 0 01.967.744L14.146 7.2 17.5 9.134a1 1 0 010 1.732l-3.354 1.935-1.18 4.455a1 1 0 01-1.933 0L9.854 12.8 6.5 10.866a1 1 0 010-1.732l3.354-1.935 1.18-4.455A1 1 0 0112 2z" clip-rule="evenodd"></path>
                                </svg>
                                Piazza Scommessa
                            </button>
                        </div>
                        
                        <!-- Anteprima vincita -->
                        <div id="win-preview" class="mt-4">
                            <div class="bg-gray-800 border border-gray-700 rounded-lg p-4 text-center">
                                <p class="text-sm text-gray-500">Seleziona tutte le partite e inserisci la puntata per vedere l'anteprima della vincita</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="placed-bets-area" class="hidden max-w-4xl mx-auto card p-6">
                    <div id="user-placed-bets-list"></div>
                </div>

                <div id="admin-panel-main" class="hidden max-w-4xl mx-auto">
                    <div class="flex justify-between items-center border-b border-blue-800">
                        <div class="flex">
                            <button onclick="showAdminTab('csv')" class="admin-tab-button px-4 py-2 text-lg font-semibold border-b-2 border-transparent hover:border-blue-400 hover:text-blue-400 focus:outline-none">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z"></path>
                                </svg>
                                Caricamento CSV
                            </button>
                            <button onclick="showAdminTab('users')" class="admin-tab-button px-4 py-2 text-lg font-semibold border-b-2 border-transparent hover:border-blue-400 hover:text-blue-400 focus:outline-none">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"></path>
                                </svg>
                                Gestione Utenti
                            </button>
                            <button onclick="showAdminTab('schedules')" class="admin-tab-button px-4 py-2 text-lg font-semibold border-b-2 border-transparent hover:border-blue-400 hover:text-blue-400 focus:outline-none">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                                </svg>
                                Orari Giornate
                            </button>
                            <button onclick="showAdminTab('bets')" class="admin-tab-button px-4 py-2 text-lg font-semibold border-b-2 border-transparent hover:border-blue-400 hover:text-blue-400 focus:outline-none">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 512 512">
                                    <path d="M177.1 228.6L207.9 320h96.5l29.62-91.38L256 172.1L177.1 228.6zM255.1 0C114.6 0 .0001 114.6 .0001 256S114.6 512 256 512s255.1-114.6 255.1-255.1S397.4 0 255.1 0z"/>
                                </svg>
                                Scommesse
                            </button>
                            <button onclick="showAdminTab('danger')" class="admin-tab-button px-4 py-2 text-lg font-semibold border-b-2 border-transparent hover:border-red-500 hover:text-red-500 focus:outline-none">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                                </svg>
                                Reset Dati
                            </button>
                        </div>
                        <button onclick="setAppView('home')" class="btn-secondary">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            Home
                        </button>
                    </div>

                    <div id="admin-tab-csv" class="admin-tab-content card p-6 mt-4">
                        <h3 class="text-xl font-bold mb-4 text-yellow-400">Caricamento Dati CSV</h3>
                        <div class="flex items-center space-x-4 mb-4">
                            <label for="csv-file-input" class="sr-only">Seleziona file CSV</label>
                            <input type="file" id="csv-file-input" class="hidden" onchange="handleFileSelect()" accept=".csv" aria-label="Seleziona file CSV">
                            <button onclick="triggerFileInput()" class="btn-primary">Seleziona File Calendario (.csv)</button>
                            <button id="upload-button" onclick="confirmUpload()" class="btn-secondary" disabled>Carica File</button>
                            <span id="file-name-display" class="text-gray-400" aria-live="polite">Nessun file selezionato.</span>
                        </div>
                        <p class="text-xs text-gray-500 mb-2">
                            Il file CSV deve avere il delimitatore ';' e il seguente tracciato: Giornata;Casa;P.Casa;P.Ospite;Ospite;Risultato.
                            Le partite con risultato (es. '2-1') verranno importate come risultati storici.
                            Le partite con risultato '-' verranno importate come partite aperte per le scommesse.
                        </p>
                        <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg px-4 py-2 mb-6">
                            <p class="text-xs text-blue-300">
                                <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                                </svg>
                                <strong>Date automatiche:</strong> Il fantacalcio √® iniziato alla 3¬™ giornata di Serie A 2025/26. Le date vengono mappate automaticamente (Giornata 1 ‚Üí 13 set 2025, Giornata 2 ‚Üí 20 set 2025, ecc.)
                            </p>
                        </div>
                        
                        <!-- Tabella dati CSV caricati -->
                        <div class="border-t border-gray-700 pt-6">
                            <h4 class="text-lg font-semibold mb-4 text-green-400">Dati Caricati</h4>
                            <div id="csv-data-container" class="overflow-x-auto">
                                <p class="text-gray-500">Nessun dato da visualizzare. Carica un file CSV.</p>
                            </div>
                        </div>
                        
                        <!-- Sezione Caricamento Rose -->
                        <div class="border-t border-gray-700 pt-6 mt-6">
                            <h4 class="text-lg font-semibold mb-4 text-purple-400">Caricamento Rose Squadre</h4>
                            <div class="flex items-center space-x-4 mb-4">
                                <label for="squads-csv-file-input" class="sr-only">Seleziona file CSV Rose</label>
                                <input type="file" id="squads-csv-file-input" class="hidden" onchange="handleSquadsFileSelect()" accept=".csv" aria-label="Seleziona file CSV Rose">
                                <button onclick="triggerSquadsFileInput()" class="btn-primary">Seleziona File Rose (.csv)</button>
                                <button id="upload-squads-button" onclick="confirmSquadsUpload()" class="btn-secondary" disabled>Carica Rose</button>
                                <span id="squads-file-name-display" class="text-gray-400" aria-live="polite">Nessun file selezionato.</span>
                            </div>
                            <p class="text-xs text-gray-500 mb-4">
                                Il file CSV deve avere il delimitatore ';' e il seguente tracciato: Squadra;Ruolo;Calciatore;Squadra (Serie A);Costo.
                                Verranno caricate tutte le rose con i calciatori di ogni squadra.
                            </p>
                            <div id="squads-data-container" class="overflow-x-auto">
                                <p class="text-gray-500 text-sm">Nessun dato rose caricato.</p>
                            </div>
                        </div>
                        
                        <!-- Sezione Caricamento Statistiche Calciatori -->
                        <div class="border-t border-gray-700 pt-6 mt-6">
                            <h4 class="text-lg font-semibold mb-4 text-blue-400">Caricamento Statistiche Calciatori</h4>
                            <div class="flex items-center space-x-4 mb-4">
                                <label for="stats-csv-file-input" class="sr-only">Seleziona file CSV Statistiche</label>
                                <input type="file" id="stats-csv-file-input" class="hidden" onchange="handleStatsFileSelect()" accept=".csv" aria-label="Seleziona file CSV Statistiche">
                                <button onclick="triggerStatsFileInput()" class="btn-primary">Seleziona File Statistiche (.csv)</button>
                                <button id="upload-stats-button" onclick="confirmStatsUpload()" class="btn-secondary" disabled>Carica Statistiche</button>
                                <span id="stats-file-name-display" class="text-gray-400" aria-live="polite">Nessun file selezionato.</span>
                            </div>
                            <p class="text-xs text-gray-500 mb-2">
                                Il file CSV deve avere il delimitatore ';' e contenere: Id;R;Nome;Squadra;Pv;Mv;Fm;Gf;Gs;Rp;Rc;R+;R-;Ass;Amm;Esp;Au
                            </p>
                            <p class="text-xs text-gray-400 mb-4">
                                <strong>Legenda:</strong> R=Ruolo, Pv=Partite a voto, Mv=Media voto, Fm=Fantamedia, Gf=Gol fatti, Gs=Gol subiti, 
                                Rp=Rigori parati, Rc=Rigori concessi, R+=Rigori segnati, R-=Rigori sbagliati, Ass=Assist, Amm=Ammonizioni, Esp=Espulsioni, Au=Autogol
                            </p>
                            <!-- Progress Bar Statistiche -->
                            <div id="stats-progress" class="mb-4 hidden">
                                <div class="flex justify-between items-center mb-2">
                                    <span id="stats-progress-status" class="text-sm text-gray-300">Inizializzazione...</span>
                                    <span id="stats-progress-percentage" class="text-sm font-bold text-blue-400">0%</span>
                                </div>
                                <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                                    <div id="stats-progress-bar-fill" class="bg-gradient-to-r from-blue-500 to-blue-600 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                            </div>
                            <div id="stats-summary-container" class="mb-4">
                                <!-- Riepilogo statistiche caricate -->
                            </div>
                            <div id="stats-data-container" class="overflow-x-auto">
                                <p class="text-gray-500 text-sm">Nessuna statistica caricata.</p>
                            </div>
                        </div>
                    </div>

                    <div id="admin-tab-users" class="admin-tab-content card p-6 mt-4 hidden">
                        <h3 class="text-xl font-bold mb-4 text-yellow-400">Gestione Utenti</h3>
                        <div id="admin-users-list" class="space-y-2">
                            <!-- Lista utenti renderizzata da JS -->
                        </div>
                    </div>

                    <div id="admin-tab-schedules" class="admin-tab-content card p-6 mt-4 hidden">
                        <h3 class="text-xl font-bold mb-4 text-yellow-400">Gestione Orari Giornate</h3>
                        
                        <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg px-4 py-3 mb-4">
                            <p class="text-sm text-blue-300">
                                <svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                                </svg>
                                <strong>Importante:</strong> Imposta l'orario della PRIMA partita della giornata. Le scommesse si chiuderanno automaticamente a quell'ora.
                                <br>Se non confermi l'orario, il sistema user√† Venerd√¨ 20:45 come orario "sicuro" di default.
                            </p>
                        </div>
                        
                        <div class="bg-yellow-900/20 border border-yellow-500/30 rounded-lg px-4 py-3 mb-6">
                            <p class="text-sm text-yellow-300">
                                <svg class="w-5 h-5 inline mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                                </svg>
                                <strong>Nota:</strong> Il Fantacalcio ha 36 giornate (Serie A giornate 3-38). 
                                Giornata Fanta 1 = Serie A 3 | Giornata Fanta 36 = Serie A 38
                            </p>
                        </div>

                        <div class="mb-4 flex space-x-4">
                            <button onclick="loadSchedulesForAdmin()" class="btn-primary">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                </svg>
                                Ricarica
                            </button>
                            <button onclick="saveAllSchedules()" class="btn-success">
                                <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                Salva Tutte le Modifiche
                            </button>
                        </div>
                        
                        <div class="overflow-x-auto">
                            <table class="w-full text-sm">
                                <thead class="bg-gray-800 border-b-2 border-yellow-500">
                                    <tr>
                                        <th class="px-3 py-2 text-left">Giornata Fanta</th>
                                        <th class="px-3 py-2 text-left text-gray-400 text-xs">(Serie A)</th>
                                        <th class="px-3 py-2 text-left">Data</th>
                                        <th class="px-3 py-2 text-left">Ora Inizio</th>
                                        <th class="px-3 py-2 text-center">Confermato</th>
                                        <th class="px-3 py-2 text-left">Note</th>
                                        <th class="px-3 py-2 text-center">Countdown</th>
                                    </tr>
                                </thead>
                                <tbody id="schedules-table-body" class="divide-y divide-gray-700">
                                    <!-- Righe renderizzate da JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div id="admin-tab-bets" class="admin-tab-content card p-6 mt-4 hidden">
                        <h3 class="text-xl font-bold mb-4 text-yellow-400">Scommesse della Giornata</h3>
                        
                        <!-- Filtri per vedere scommesse liquidate/non liquidate -->
                        <div class="mb-4 flex space-x-4">
                            <button onclick="renderAdminBetsFilter('all')" id="filter-all" class="btn-secondary">Tutte</button>
                            <button onclick="renderAdminBetsFilter('pending')" id="filter-pending" class="btn-primary">Da Liquidare</button>
                            <button onclick="renderAdminBetsFilter('settled')" id="filter-settled" class="btn-secondary">Liquidate</button>
                        </div>
                        
                        <div id="admin-bets-list">
                            <!-- Lista scommesse renderizzata da JS -->
                        </div>
                    </div>

                    <div id="admin-tab-danger" class="admin-tab-content card p-6 mt-4 hidden border-red-600">
                        <h3 class="text-xl font-bold mb-6 text-red-400">Reset Dati</h3>
                        
                        <div class="space-y-6">
                            <!-- Cancella Risultati Storici -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Risultati Storici</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutti i risultati storici caricati da CSV (giornate gi√† completate).</p>
                                <button onclick="clearHistoricResults()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Risultati Storici
                                </button>
                            </div>

                            <!-- Cancella Partite Aperte -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Partite Aperte</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutte le partite aperte (giornate future disponibili per le scommesse).</p>
                                <button onclick="clearOpenMatches()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Partite Aperte
                                </button>
                            </div>

                            <!-- Cancella Scommesse -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Tutte le Scommesse</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutte le scommesse piazzate dagli utenti (non restituisce i crediti).</p>
                                <button onclick="clearAllBets()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Scommesse
                                </button>
                            </div>

                            <!-- Reset Crediti Utenti -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Reset Crediti Utenti</h4>
                                <p class="text-sm text-gray-400 mb-3">Reimposta i crediti di tutti gli utenti a 100 (valore predefinito).</p>
                                <button onclick="resetUserCredits()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                    Reset Crediti (100 per tutti)
                                </button>
                            </div>

                            <!-- Cancella Squadre -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Tutte le Squadre</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutte le squadre dal database. Da usare solo per reset completo.</p>
                                <button onclick="clearAllTeams()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Squadre
                                </button>
                            </div>

                            <!-- Cancella Rose Squadre -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Rose Squadre</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutte le rose caricate (calciatori e informazioni squadre fantacalcio).</p>
                                <button onclick="clearSquadsData()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Rose
                                </button>
                            </div>

                            <!-- Cancella Statistiche Calciatori -->
                            <div class="border border-gray-700 rounded-lg p-4">
                                <h4 class="font-semibold text-lg mb-2 text-red-300">Cancella Statistiche Calciatori</h4>
                                <p class="text-sm text-gray-400 mb-3">Rimuove tutte le statistiche dei calciatori caricate da CSV.</p>
                                <button onclick="clearPlayerStats()" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                    </svg>
                                    Cancella Statistiche
                                </button>
                            </div>

                            <!-- Reset Totale -->
                            <div class="border-2 border-red-500 rounded-lg p-4 bg-red-900 bg-opacity-10">
                                <h4 class="font-semibold text-lg mb-2 text-red-400">‚ö†Ô∏è RESET TOTALE</h4>
                                <p class="text-sm text-gray-300 mb-3 font-semibold">Cancella TUTTO: squadre, partite, risultati storici, scommesse. Questa azione √® IRREVERSIBILE!</p>
                                <button onclick="clearHistoricResultsAndTeams(false)" class="btn-danger">
                                    <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                                    </svg>
                                    RESET COMPLETO
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="profile-area" class="hidden max-w-md mx-auto card p-6">
                    <h2 class="text-2xl font-bold mb-6 text-center flex items-center justify-center">
                        <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"></path>
                        </svg>
                        Profilo Utente
                    </h2>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Email (non modificabile)</label>
                        <input id="profile-email" class="bg-gray-900 cursor-not-allowed opacity-75" type="email" readonly />
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm font-medium text-gray-300 mb-2">Nome visualizzato</label>
                        <input id="profile-display-name" type="text" placeholder="@username" />
                        <p class="text-xs text-gray-500 mt-1">Questo nome sar√† visibile agli altri utenti</p>
                    </div>
                    
                    <div class="flex justify-center space-x-4">
                        <button onclick="setAppView('home')" class="btn-secondary">
                            <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
                            </svg>
                            Home
                        </button>
                        <button onclick="saveUserProfile()" class="btn-primary">
                            <svg class="w-4 h-4 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h5a2 2 0 012 2v7a2 2 0 01-2 2H4a2 2 0 01-2-2V8a2 2 0 012-2h5v5.586l-1.293-1.293zM9 4a1 1 0 012 0v2H9V4z"></path>
                            </svg>
                            Salva Profilo
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-app.js";
        import {
            getFirestore,
            collection,
            doc,
            setDoc,
            getDoc,
            updateDoc,
            deleteDoc,
            onSnapshot,
            query,
            where,
            orderBy,
            limit,
            getDocs,
            addDoc,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-firestore.js";
        import {
            getAuth,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/9.6.11/firebase-auth.js";

            // Configurazione Firebase (DA SOSTITUIRE CON LE TUE CREDENZIALI)
        // Vai sulla console Firebase del tuo progetto, vai su "Impostazioni progetto" e nella sezione "Generali"
        // cerca "Le tue app". Seleziona l'app web e copia l'oggetto di configurazione.
           const firebaseConfig = {
      apiKey: "AIzaSyD9FAyUKCHkP9v_gEWnh4kLDFjyKMKWw74",
      authDomain: "fantabet-op.firebaseapp.com",
      projectId: "fantabet-op",
      storageBucket: "fantabet-op.firebasestorage.app",
      messagingSenderId: "1042496289193",
      appId: "1:1042496289193:web:9e62956ef2da506b80ecb8"
    };

        // --- Variabili Globali ---
        let db, auth;
        let userId = null;
        let userCredits = 100; // Crediti utente, inizializzati a 100 per test
        let isUserAdmin = false;
        // Lista admin (fallback vuota). Imposta window.ADMIN_USER_IDS = ['uid1','uid2'] se vuoi preconfigurare admin.
        const ADMIN_USER_IDS = Array.isArray(window.ADMIN_USER_IDS) ? window.ADMIN_USER_IDS : ['zfnVEz13IYZchLxxWTwi6htI5cU2'];
        
        // Mappatura loghi squadre
        const GITHUB_USERNAME = 'savinopi';
        const GITHUB_REPO = 'FantaBet-OP';
        const LOGOS_FOLDER = ''; // I loghi sono nella root del repository
        const GITHUB_LOGOS_BASE_URL = `https://raw.githubusercontent.com/${GITHUB_USERNAME}/${GITHUB_REPO}/main`;
        
        const TEAM_LOGOS = {
            'Audace Cerignola Next Gen': 'Logo Audace Cerignola.png',
            'Disagiati FC': 'Logo Disagiati FC.png',
            'Friariello FC': 'Logo Friarello FC 2025.png',
            'LIBERTAS': 'Logo Libertas.png',
            'Tarzanelli': 'Logo Tarzanelli.png',
            'FC SANTA CLAUS': 'Logo santa claus.png',
            'Monte Los Angeles Fc': 'MONTE.png',
            'Schalke 104': 'Schalke104_2024.png',
            'A.S. UDINEGRE': 'UDINEGRE.png',
            'Panza Team': 'logo panza team.png'
        };
        
        // Funzione helper per ottenere il logo di una squadra
        const getTeamLogo = (teamName) => {
            const logoFile = TEAM_LOGOS[teamName];
            if (logoFile) {
                return `${GITHUB_LOGOS_BASE_URL}/${encodeURIComponent(logoFile)}`;
            }
            // Logo placeholder se non trovato
            return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='50' height='50' viewBox='0 0 50 50'%3E%3Crect width='50' height='50' fill='%23374151'/%3E%3Ctext x='25' y='25' font-size='20' text-anchor='middle' dominant-baseline='middle' fill='%239CA3AF'%3E${teamName.charAt(0)}%3C/text%3E%3C/svg%3E`;
        };
        
        // Dati per la gestione delle squadre e risultati
        let allTeams = [];
        let allResults = [];
        let allMatches = [];
        
        // Stato per le scommesse aperte
        let openMatches = [];
        let nextGiornataNumber = 0;
        
        // Stato per le scommesse piazzate dall'utente
        let userPlacedBets = [];
        let currentPredictions = {}; // Per le scommesse di gruppo
        
        // Stato per l'ordinamento della classifica
        let standingsSortColumn = null;
        let standingsSortDirection = 'asc';
        
        // Timer per countdown deadline scommesse
        let countdownInterval = null;
        
        // --- Variabili per la gestione admin ---
        let adminBetsUnsubscribe = null;
        let allUsersForAdmin = [];
        let currentUserProfile = null;
        let localCsvContent = null;
        let parsedCsvData = [];
        let currentView = 'home';

        window.showAdminTab = async (tabName) => {
            // Hide all tab content
            document.querySelectorAll('.admin-tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            // Deactivate all tab buttons
            document.querySelectorAll('.admin-tab-button').forEach(button => {
                button.classList.remove('text-green-400', 'border-green-400', 'text-red-500', 'border-red-500');
            });

            // Show the selected tab content
            document.getElementById(`admin-tab-${tabName}`).classList.remove('hidden');
            // Activate the selected tab button
            const activeButton = document.querySelector(`button[onclick="showAdminTab('${tabName}')"]`);
            if (tabName === 'danger') {
                activeButton.classList.add('text-red-500', 'border-red-500');
            } else {
                activeButton.classList.add('text-green-400', 'border-green-400');
            }
            
            // Carica i dati specifici della tab
            if (tabName === 'bets') {
                // Carica tutte le scommesse
                const snapshot = await getDocs(getGiornataBetsCollectionRef());
                const allBets = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                const usersSnapshot = await getDocs(getUsersCollectionRef());
                const allUsers = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                renderAdminBetsList(allBets, allUsers, currentBetsFilter);
            } else if (tabName === 'schedules') {
                // Carica gli orari delle giornate
                await loadSchedulesForAdmin();
            }
        };

        window.setAppView = (view) => {
            console.log('setAppView chiamato con view:', view);
            
            // Ferma il timer del countdown se stiamo uscendo dalla sezione betting
            if (currentView === 'betting' && view !== 'betting' && countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            currentView = view;
            const containers = {
                home: 'home-container',
                betting: 'betting-area',
                placed_bets: 'placed-bets-area',
                admin: 'admin-panel-main',
                profile: 'profile-area',
                historic_results: 'historic-results-container',
                squads: 'squads-container',
                player_stats: 'player-stats-container'
            };

            console.log('Container disponibili:', containers);

            // Nascondi tutte le sezioni principali
            Object.values(containers).forEach(id => {
                const el = document.getElementById(id);
                console.log(`Cercando elemento ${id}:`, el ? 'trovato' : 'non trovato');
                if (el) el.classList.add('hidden');
            });

            // Mostra solo la sezione richiesta
            const viewId = containers[view];
            if (viewId) {
                const el = document.getElementById(viewId);
                console.log(`Tentativo di mostrare ${viewId}:`, el ? 'elemento trovato' : 'elemento non trovato');
                if (el) {
                    el.classList.remove('hidden');
                    // Se stiamo passando alla sezione scommesse, forziamo il refresh
                    if (view === 'betting') {
                        console.log('Passaggio a sezione scommesse, aggiorno lista partite...');
                        // Forza il refresh delle partite
                        if (allMatches && allMatches.length > 0) {
                            console.log('Partite disponibili:', allMatches.length);
                            const lastCompletedGiornata = determineLastCompletedGiornata();
                            const newNextGiornata = lastCompletedGiornata + 1;
                            console.log('Rendering partite per giornata (setAppView):', newNextGiornata);
                            renderOpenMatches(allMatches, newNextGiornata);
                        } else {
                            console.log('Nessuna partita disponibile in allMatches');
                        }
                    }
                    // Se stiamo passando alla sezione profilo, popola i campi
                    if (view === 'profile') {
                        renderProfileArea();
                    }
                    // Se stiamo passando alla home, carica le statistiche calciatori
                    if (view === 'home') {
                        loadPlayerLeaderboards();
                    }
                    // Se stiamo passando alla sezione rose, carica i dati
                    if (view === 'squads') {
                        loadSquadsData();
                    }
                    // Se stiamo passando alla sezione statistiche, carica i dati
                    if (view === 'player_stats') {
                        loadPlayerStats();
                    }
                }
            }

            if (view === 'admin') {
                showAdminTab('csv');
            }
        };

        // --- Funzioni di utilit√† ---
        const messageBox = (message) => {
            const messageText = document.getElementById('message-text');
            const messageBoxElement = document.getElementById('message-box');
            if (messageText && messageBoxElement) {
                messageText.textContent = message;
                messageBoxElement.classList.remove('hidden');
            }
        };

        window.hideMessageBox = () => {
            const messageBoxElement = document.getElementById('message-box');
            if (messageBoxElement) {
                messageBoxElement.classList.add('hidden');
            }
        };

        // --- Funzioni Barra di Progresso ---
        let progressStartTime = null;
        
        const showProgressBar = (title = 'Elaborazione in corso...') => {
            const container = document.getElementById('progress-bar-container');
            const titleElement = document.getElementById('progress-title');
            if (container && titleElement) {
                titleElement.textContent = title;
                container.classList.remove('hidden');
                updateProgress(0, 'Inizializzazione...');
                progressStartTime = Date.now();
            }
        };

        const hideProgressBar = () => {
            const container = document.getElementById('progress-bar-container');
            if (container) {
                container.classList.add('hidden');
                progressStartTime = null;
            }
        };

        const updateProgress = (percentage, statusText = '', current = null, total = null, progressId = 'progress') => {
            // Supporta sia la progress bar principale che quelle con ID personalizzato
            const prefix = progressId === 'progress' ? 'progress' : progressId;
            const fillId = progressId === 'progress' ? 'progress-bar-fill' : `${progressId}-bar-fill`;
            const percentageId = progressId === 'progress' ? 'progress-percentage' : `${progressId}-percentage`;
            const statusId = progressId === 'progress' ? 'progress-status' : `${progressId}-status`;
            const timeId = progressId === 'progress' ? 'progress-time' : `${progressId}-time`;
            const containerId = progressId;
            
            // Mostra il container se nascosto
            const container = document.getElementById(containerId);
            if (container && container.classList.contains('hidden')) {
                container.classList.remove('hidden');
            }
            
            const fill = document.getElementById(fillId);
            const percentageText = document.getElementById(percentageId);
            const status = document.getElementById(statusId);
            const timeElement = document.getElementById(timeId);
            
            if (fill && percentageText) {
                const clampedPercentage = Math.min(100, Math.max(0, percentage));
                fill.style.width = clampedPercentage + '%';
                percentageText.textContent = Math.round(clampedPercentage) + '%';
            }
            
            if (status && statusText) {
                status.textContent = statusText;
            }
            
            // Calcola tempo rimanente
            if (timeElement && progressStartTime && percentage > 0 && percentage < 100) {
                const elapsed = (Date.now() - progressStartTime) / 1000; // secondi
                const estimatedTotal = (elapsed / percentage) * 100;
                const remaining = estimatedTotal - elapsed;
                
                if (remaining > 0) {
                    const minutes = Math.floor(remaining / 60);
                    const seconds = Math.round(remaining % 60);
                    
                    let timeText = 'Tempo stimato: ';
                    if (minutes > 0) {
                        timeText += `${minutes}m ${seconds}s`;
                    } else {
                        timeText += `${seconds}s`;
                    }
                    
                    if (current !== null && total !== null) {
                        timeText += ` (${current}/${total})`;
                    }
                    
                    timeElement.textContent = timeText;
                } else {
                    timeElement.textContent = '';
                }
            } else if (timeElement) {
                if (current !== null && total !== null) {
                    timeElement.textContent = `(${current}/${total})`;
                } else {
                    timeElement.textContent = '';
                }
            }
        };
        
        const hideProgress = (progressId = 'progress') => {
            const container = document.getElementById(progressId);
            if (container) {
                container.classList.add('hidden');
            }
        };

        // --- Gestione Admin ---
        const checkAdminStatus = () => {
             try {
                 isUserAdmin = Array.isArray(ADMIN_USER_IDS) && ADMIN_USER_IDS.includes(userId);
             } catch (e) {
                 console.warn('checkAdminStatus: errore controllo admin:', e);
                 isUserAdmin = false;
             }

             const adminButton = document.getElementById('admin-button-home');
             if (adminButton) {
                 adminButton.classList.toggle('hidden', !isUserAdmin);
             }
             return isUserAdmin;
        };
        
        window.triggerFileInput = () => {
            document.getElementById('csv-file-input').click();
        }

        // --- Gestione Autenticazione ---
        
        window.handleLoginRegister = async (isLogin) => {
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            
            if (!email || !password) {
                messageBox("Inserisci email e password.");
                return;
            }

            try {
                let userCredential;
                if (isLogin) {
                    userCredential = await signInWithEmailAndPassword(auth, email, password);
                } else {
                    userCredential = await createUserWithEmailAndPassword(auth, email, password);
                }
                
                const user = userCredential.user;
                console.log("User authenticated:", user.uid);
                
                // Crea o aggiorna sempre il documento utente
                const userDocRef = doc(getUsersCollectionRef(), user.uid);
                
                try {
                    // Prima verifica se √® un admin predefinito
                    const isDefaultAdmin = ADMIN_USER_IDS.includes(user.uid);
                    console.log("Is default admin:", isDefaultAdmin);
                    
                    // Ottieni il documento esistente se presente
                    const userDoc = await getDoc(userDocRef);
                    const existingData = userDoc.exists() ? userDoc.data() : {};
                    
                    // Prepara i dati da salvare
                    const userData = {
                        ...existingData,
                        email: user.email,
                        displayName: existingData.displayName || user.email.split('@')[0],
                        credits: existingData.credits !== undefined ? existingData.credits : 100,
                        isAdmin: existingData.isAdmin !== undefined ? existingData.isAdmin : isDefaultAdmin,
                        lastLogin: new Date().toISOString(),
                        ...((!userDoc.exists()) && { createdAt: new Date().toISOString() })
                    };
                    
                    // Salva o aggiorna il documento
                    await setDoc(userDocRef, userData);
                    console.log("User document saved:", userData);
                    
                    messageBox(isLogin ? 
                        "Accesso riuscito!" : 
                        "Registrazione completata! Profilo utente creato.");
                        
                } catch (dbError) {
                    console.error("Errore salvataggio documento utente:", dbError);
                    messageBox("Errore nel salvataggio del profilo. Contatta l'admin.");
                }
            } catch (error) {
                console.error("Errore Autenticazione:", error);
                let errorMessage = "Errore di autenticazione.";

                if (error.code === 'auth/invalid-credential' || error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    errorMessage = "Credenziali non valide. Controlla email e password. Hai provato prima a **Registrarti**?";
                } else if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Questa email √® gi√† registrata. Prova ad accedere.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "La password deve essere di almeno 6 caratteri.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Formato email non valido.";
                }
                
                messageBox(errorMessage);
            }
        };
        
        // Array per tenere traccia di tutti i listener attivi
        let activeUnsubscribes = [];

        // Funzione per aggiungere un unsubscribe alla lista
        const addUnsubscribe = (unsubscribe) => {
            if (typeof unsubscribe === 'function') {
                activeUnsubscribes.push(unsubscribe);
            }
        };

        // Funzione per rimuovere tutti i listener
        const removeAllListeners = () => {
            console.log('Removing all listeners:', activeUnsubscribes.length);
            while (activeUnsubscribes.length > 0) {
                const unsubscribe = activeUnsubscribes.pop();
                try {
                    unsubscribe();
                } catch (e) {
                    console.error('Error unsubscribing:', e);
                }
            }
        };

        window.handleLogout = async () => {
            try {
                // Prima rimuovi tutti i listener
                removeAllListeners();
                // Poi esegui il logout
                await signOut(auth);
                console.log('Logout completato e listener rimossi');
            } catch (error) {
                console.error("Errore Logout:", error);
                messageBox("Errore durante il logout.");
            }
        };

        const setupFirebase = async () => {
            if (!firebaseConfig.apiKey) {
                document.getElementById('auth-status').textContent = 'Errore: Configurazione Firebase mancante.';
                messageBox('Errore di configurazione Firebase. Impossibile avviare l\'app.');
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            document.getElementById('auth-status').textContent = 'In attesa di autenticazione...';
            
            onAuthStateChanged(auth, async (user) => {
                const loginContainer = document.getElementById('login-container');
                const mainAppContainer = document.getElementById('main-app-container');
                const logoutButton = document.getElementById('logout-button');
                const authStatus = document.getElementById('auth-status');

                if (user) {
                    userId = user.uid;
                    authStatus.textContent = 'Autenticato';
                    authStatus.classList.add('hidden'); // Nascondi dopo l'autenticazione

                    loginContainer.classList.add('hidden');
                    mainAppContainer.classList.remove('hidden');
                    logoutButton.classList.remove('hidden');

                    checkAdminStatus(); 
                    updateUserInfoDisplay();
                    setupUserProfileListener(userId); // Imposta il listener per il profilo utente
                    setupListeners();

                    if (isUserAdmin) {
                        await loadInitialData();
                    }
                    
                    // Va alla schermata home di default
                    setAppView('home');

                    // Forza nascondere la sezione risultati storici e assicurati che la home sia visibile
                    const hr = document.getElementById('historic-results-container');
                    if (hr) hr.classList.add('hidden');
                    const homeEl = document.getElementById('home-container');
                    if (homeEl) homeEl.classList.remove('hidden');

                    const today = new Date().toISOString().split('T')[0];
                    if (document.getElementById('historic-date')) document.getElementById('historic-date').value = today;
                    if (document.getElementById('new-match-date')) document.getElementById('new-match-date').value = today;

                } else {
                    userId = null;
                    authStatus.textContent = 'Non autenticato';
                    authStatus.classList.remove('hidden');

                    const userDisplayNameElement = document.getElementById('user-display-name');
                    if (userDisplayNameElement) userDisplayNameElement.textContent = ''; // Pulisci il nome visualizzato

                    logoutButton.classList.add('hidden');

                    loginContainer.classList.remove('hidden');
                    mainAppContainer.classList.add('hidden');
                }
            });
        };

        // --- Funzioni Crediti ---
        const updateUserInfoDisplay = () => {
            const userCreditsElement = document.getElementById('user-credits-display'); 
            const userDisplayNameElement = document.getElementById('user-display-name');
            const userRoleElement = document.getElementById('user-role-display');
            const userIdElement = document.getElementById('user-id-display');

            if (userCreditsElement) userCreditsElement.textContent = `Crediti Bonus: ${userCredits}`;
            if (userDisplayNameElement && currentUserProfile) { 
                userDisplayNameElement.textContent = currentUserProfile.displayName || currentUserProfile.email;
            }
            if (userRoleElement) {
                userRoleElement.textContent = isUserAdmin ? 'Admin' : 'Utente';
            }
            if (userIdElement && userId) {
                userIdElement.textContent = `ID: ${userId}`;
            }
        };

        const adjustCredits = async (amount) => {
            userCredits += amount;
            updateUserInfoDisplay();
            
            // Aggiorna anche su Firestore
            if (userId) {
                try {
                    const userRef = doc(getUsersCollectionRef(), userId);
                    await updateDoc(userRef, {
                        credits: userCredits
                    });
                    console.log('Crediti aggiornati su Firestore:', userCredits);
                } catch (error) {
                    console.error('Errore aggiornamento crediti su Firestore:', error);
                }
            }
        }

        // --- Accesso a Firestore ---
        const getTeamCollectionRef = () => collection(db, 'fantabet_teams');
        const getResultsCollectionRef = () => collection(db, 'fantabet_results');
        const getMatchesCollectionRef = () => collection(db, 'fantabet_matches');
        // Usa una collezione per le scommesse per singola giornata
        const getGiornataBetsCollectionRef = () => collection(db, 'fantabet_giornata_bets'); 
        const getUsersCollectionRef = () => collection(db, 'fantabet_users');
        const getSquadsCollectionRef = () => collection(db, 'fantabet_squads'); // Collection per le rose
        const getPlayersCollectionRef = () => collection(db, 'fantabet_players'); // Collection per i calciatori
        const getPlayerStatsCollectionRef = () => collection(db, 'fantabet_player_stats'); // Collection per le statistiche calciatori
        
        // --- Gestione Teams e UI ---

        const updateTeamSelects = (teams) => {
            const selects = [
                'historic-home-team', 'historic-away-team',
                'new-match-home-team', 'new-match-away-team'
            ];
            
            selects.forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '';
                    teams.forEach(team => {
                        const option = document.createElement('option');
                        option.value = team;
                        option.textContent = team;
                        select.appendChild(option);
                    });
                }
            });

            renderTeamList(teams);
        };
        
        const renderTeamList = (teams) => {
            const listContainer = document.getElementById('team-list');
            if (listContainer) {
                listContainer.innerHTML = '';
                if (teams.length === 0) {
                    listContainer.textContent = 'Nessuna squadra aggiunta.';
                } else {
                    teams.forEach(team => {
                        const div = document.createElement('div');
                        div.className = 'text-sm text-gray-400 p-1';
                        div.textContent = team;
                        listContainer.appendChild(div);
                    });
                }
            }
        };

        const addTeamToFirestore = async (teamName) => {
            const teamId = teamName.toLowerCase().replace(/[^a-z0-9]/g, '');
            try {
                await setDoc(doc(getTeamCollectionRef(), teamId), {
                    name: teamName
                });
            } catch (error) {
                console.error("Errore salvataggio squadra:", error);
                messageBox(`Errore nel salvataggio della squadra ${teamName}.`);
            }
        };

        window.addTeam = async () => {
            if (!isUserAdmin) return;
            const teamNameInput = document.getElementById('new-team-name');
            const teamName = teamNameInput.value.trim();
            if (teamName && !allTeams.includes(teamName)) {
                await addTeamToFirestore(teamName);
                teamNameInput.value = '';
                messageBox(`Squadra "${teamName}" aggiunta.`);
            } else if (teamName) {
                messageBox(`Squadra "${teamName}" √® gi√† presente.`);
            }
        };
        
        // --- Gestione Risultati Storici ---

        // Funzione per formattare la data in formato leggibile italiano
        const formatDateItalian = (dateString) => {
            if (!dateString) return '-';
            const date = new Date(dateString + 'T00:00:00'); // Aggiungi orario per evitare problemi timezone
            const options = { day: '2-digit', month: 'short', year: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        };

        const renderHistoricResults = (results) => {
            const tableBody = document.getElementById('historic-results-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            // 1. Raggruppa i risultati per giornata
            const resultsByGiornata = results.reduce((acc, res) => {
                const giornata = res.giornata || 'Senza Giornata';
                (acc[giornata] = acc[giornata] || []).push(res);
                return acc;
            }, {});

            const resultMap = { '1': 'Vittoria Casa (1)', 'X': 'Pareggio (X)', '2': 'Vittoria Ospite (2)' };

            // helper: estrai numero dalla stringa (se presente)
            const extractNumber = s => {
                const m = (s || '').match(/\d+/);
                return m ? parseInt(m[0], 10) : 999;
            };

            // 2. Ordina le giornate in modo sicuro
            const sortedGiornate = Object.keys(resultsByGiornata).sort((a, b) => extractNumber(a) - extractNumber(b));

            // 3. Costruisci DOM usando fragment per ridurre repaint
            const frag = document.createDocumentFragment();

            sortedGiornate.forEach(giornata => {
                // Ordina le partite all'interno della giornata per data
                resultsByGiornata[giornata].sort((a, b) => new Date(a.date) - new Date(b.date));

                // Intestazione Giornata
                const headerRow = document.createElement('tr');
                headerRow.className = 'giornata-header bg-gray-700';
                headerRow.innerHTML = `<th colspan="6" class="text-left">${giornata.startsWith('Aggiunta Manuale') ? giornata : 'Giornata ' + giornata}</th>`;
                frag.appendChild(headerRow);

                // Partite della Giornata
                resultsByGiornata[giornata].forEach(res => {
                    const row = document.createElement('tr');
                    row.className = 'hover:bg-gray-800';
                    
                    // Determina le classi per evidenziare il vincitore
                    let homeTeamClass = 'text-white font-semibold';
                    let awayTeamClass = 'text-white font-semibold';
                    
                    if (res.result === '1') {
                        // Vittoria casa
                        homeTeamClass = 'text-blue-400 font-bold';
                        awayTeamClass = 'text-gray-500 font-normal';
                    } else if (res.result === '2') {
                        // Vittoria ospite
                        homeTeamClass = 'text-gray-500 font-normal';
                        awayTeamClass = 'text-blue-400 font-bold';
                    } else if (res.result === 'X') {
                        // Pareggio - entrambe in arancione
                        homeTeamClass = 'text-orange-400 font-semibold';
                        awayTeamClass = 'text-orange-400 font-semibold';
                    }
                    
                    row.innerHTML = `
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">${giornata}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-blue-400 font-medium">${formatDateItalian(res.date)}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm ${homeTeamClass}">${res.homeTeam}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm ${awayTeamClass}">${res.awayTeam}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-bold text-center ${res.result === '1' ? 'text-green-500' : res.result === '2' ? 'text-red-500' : 'text-yellow-500'}">${resultMap[res.result] || '-'}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-bold text-center text-blue-400">${res.score || '-'}</td>
                    `;
                    frag.appendChild(row);
                });
            });

            tableBody.appendChild(frag);
        };

        window.addHistoricResult = async () => {
            if (!isUserAdmin) return;
            const homeTeam = document.getElementById('historic-home-team').value;
            const awayTeam = document.getElementById('historic-away-team').value;
            const result = document.getElementById('historic-result').value;
            const date = document.getElementById('historic-date').value;

            if (!homeTeam || !awayTeam || !result || !date || homeTeam === awayTeam) {
                messageBox("Seleziona entrambe le squadre, il risultato e la data. Le squadre non possono essere le stesse.");
                return;
            }

            try {
                await addDoc(getResultsCollectionRef(), {
                    homeTeam,
                    awayTeam,
                    result, // '1', 'X', '2'
                    date,
                    giornata: 'Aggiunta Manuale', // Aggiunge un nome di giornata per i risultati manuali
                    score: 'N/A' // Punteggio fittizio
                });
                messageBox(`Risultato storico ${result} (${homeTeam} vs ${awayTeam}) salvato.`);
            } catch (error) {
                console.error("Errore salvataggio risultato storico:", error);
                messageBox("Errore nel salvataggio del risultato storico.");
            }
        };
        
        // --- Funzione di pulizia del database ---
        window.clearHistoricResultsAndTeams = async (confirmed) => {
             if (!isUserAdmin) return; 
             
             const confirmModal = document.getElementById('confirm-modal');
             
             if (!confirmed) {
                 confirmModal.classList.remove('hidden');
                 return;
             }
             
             confirmModal.classList.add('hidden');
             
             showProgressBar('Reset Totale Database');

             const collectionsToClear = [
                 getTeamCollectionRef(), 
                 getResultsCollectionRef(), 
                 getMatchesCollectionRef(),
                 getGiornataBetsCollectionRef() // Nuova collezione di scommesse
             ];
             
             let totalDeleted = 0;
             let totalDocs = 0;

             try {
                 // Prima conta tutti i documenti
                 const snapshots = await Promise.all(collectionsToClear.map(ref => getDocs(ref)));
                 totalDocs = snapshots.reduce((sum, snapshot) => sum + snapshot.docs.length, 0);
                 
                 updateProgress(10, 'Inizio cancellazione...', 0, totalDocs);
                 
                 let currentIndex = 0;
                 for (let i = 0; i < collectionsToClear.length; i++) {
                     const collectionRef = collectionsToClear[i];
                     const snapshot = snapshots[i];
                     let collectionDeleted = 0;
                     
                     // Cancella ogni documento uno per uno
                     for (const docSnapshot of snapshot.docs) {
                         await deleteDoc(doc(collectionRef, docSnapshot.id));
                         collectionDeleted++;
                         totalDeleted++;
                         currentIndex++;
                         
                         const progress = 10 + (currentIndex / totalDocs) * 85;
                         updateProgress(progress, `Cancellazione ${collectionRef.id}...`, currentIndex, totalDocs);
                     }
                     console.log(`Cancellati ${collectionDeleted} documenti dalla collezione: ${collectionRef.id}`);
                 }
                 
                 updateProgress(100, 'Completato!', totalDocs, totalDocs);
                 
                 setTimeout(() => {
                     hideProgressBar();
                     messageBox(`Cancellazione completa! Eliminati ${totalDeleted} documenti totali. L'app √® stata resettata.`);
                 }, 500);
                 
             } catch (error) {
                 console.error("Errore durante la cancellazione dei dati:", error);
                 hideProgressBar();
                 messageBox(`Errore grave durante la cancellazione. Controlla i permessi di scrittura/cancellazione su Firebase. Errore: ${error.message}`);
             }
         };

        // --- Funzioni per cancellare singole sezioni ---
        
        window.clearHistoricResults = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTI i risultati storici? Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Cancellazione Risultati Storici');
            
            try {
                const snapshot = await getDocs(getResultsCollectionRef());
                const totalDocs = snapshot.docs.length;
                let deletedCount = 0;
                
                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(getResultsCollectionRef(), docSnapshot.id));
                    deletedCount++;
                    
                    const progress = (deletedCount / totalDocs) * 100;
                    updateProgress(progress, `Cancellazione in corso...`, deletedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellati ${deletedCount} risultati storici.`);
                console.log(`Cancellati ${deletedCount} risultati storici`);
                
                // Aggiorna le viste
                allResults = []; // Svuota array locale
                if (currentAppView === 'betting') {
                    renderOpenMatches(); // Aggiorna sezione scommesse
                }
            } catch (error) {
                console.error("Errore cancellazione risultati storici:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };

        window.clearOpenMatches = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTE le partite aperte? Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Cancellazione Partite Aperte');
            
            try {
                const q = query(getMatchesCollectionRef(), where('status', '==', 'open'));
                const snapshot = await getDocs(q);
                const totalDocs = snapshot.docs.length;
                let deletedCount = 0;
                
                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(getMatchesCollectionRef(), docSnapshot.id));
                    deletedCount++;
                    
                    const progress = (deletedCount / totalDocs) * 100;
                    updateProgress(progress, `Cancellazione in corso...`, deletedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellate ${deletedCount} partite aperte.`);
                console.log(`Cancellate ${deletedCount} partite aperte`);
                
                // Aggiorna le viste
                allMatches = allMatches.filter(m => m.status !== 'open'); // Rimuovi dall'array locale
                openMatches = [];
                currentPredictions = {};
                if (currentAppView === 'betting') {
                    renderOpenMatches(); // Aggiorna sezione scommesse
                }
            } catch (error) {
                console.error("Errore cancellazione partite aperte:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };

        window.clearAllBets = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTE le scommesse? I crediti NON verranno restituiti agli utenti. Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Cancellazione Scommesse');
            
            try {
                const snapshot = await getDocs(getGiornataBetsCollectionRef());
                const totalDocs = snapshot.docs.length;
                let deletedCount = 0;
                
                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(getGiornataBetsCollectionRef(), docSnapshot.id));
                    deletedCount++;
                    
                    const progress = (deletedCount / totalDocs) * 100;
                    updateProgress(progress, `Cancellazione in corso...`, deletedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellate ${deletedCount} scommesse.`);
                console.log(`Cancellate ${deletedCount} scommesse`);
                
                // Aggiorna le viste
                if (currentView === 'betting') {
                    renderOpenMatches(openMatches, nextGiornataNumber); // Aggiorna sezione scommesse
                }
            } catch (error) {
                console.error("Errore cancellazione scommesse:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };

        window.resetUserCredits = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler reimpostare i crediti di TUTTI gli utenti a 100? Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Reset Crediti Utenti');
            
            try {
                const snapshot = await getDocs(getUsersCollectionRef());
                const totalDocs = snapshot.docs.length;
                let updatedCount = 0;
                
                for (const docSnapshot of snapshot.docs) {
                    await updateDoc(doc(getUsersCollectionRef(), docSnapshot.id), { credits: 100 });
                    updatedCount++;
                    
                    const progress = (updatedCount / totalDocs) * 100;
                    updateProgress(progress, `Reset in corso...`, updatedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Crediti reimpostati per ${updatedCount} utenti.`);
                console.log(`Crediti reimpostati per ${updatedCount} utenti`);
            } catch (error) {
                console.error("Errore reset crediti:", error);
                hideProgressBar();
                messageBox(`Errore durante il reset: ${error.message}`);
            }
        };

        window.clearAllTeams = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTE le squadre? Questa azione √® irreversibile e potrebbe causare problemi se ci sono partite o risultati associati.')) {
                return;
            }
            
            showProgressBar('Cancellazione Squadre');
            
            try {
                const snapshot = await getDocs(getTeamsCollectionRef());
                const totalDocs = snapshot.docs.length;
                let deletedCount = 0;
                
                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(getTeamsCollectionRef(), docSnapshot.id));
                    deletedCount++;
                    
                    const progress = (deletedCount / totalDocs) * 100;
                    updateProgress(progress, `Cancellazione in corso...`, deletedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellate ${deletedCount} squadre.`);
                console.log(`Cancellate ${deletedCount} squadre`);
            } catch (error) {
                console.error("Errore cancellazione squadre:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };

        window.clearSquadsData = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTE le rose squadre (calciatori e aggregati)? Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Cancellazione Rose');
            
            try {
                updateProgress(0, 'Cancellazione calciatori...');
                
                // Cancella tutti i calciatori
                const playersSnapshot = await getDocs(getPlayersCollectionRef());
                const playerDocs = playersSnapshot.docs.length;
                let deletedPlayers = 0;
                
                for (const docSnapshot of playersSnapshot.docs) {
                    await deleteDoc(doc(getPlayersCollectionRef(), docSnapshot.id));
                    deletedPlayers++;
                    
                    const progress = (deletedPlayers / playerDocs) * 50;
                    updateProgress(progress, `Cancellazione calciatori...`, deletedPlayers, playerDocs);
                }
                
                updateProgress(50, 'Cancellazione info squadre...');
                
                // Cancella le informazioni aggregate squadre
                const squadsSnapshot = await getDocs(getSquadsCollectionRef());
                const squadDocs = squadsSnapshot.docs.length;
                let deletedSquads = 0;
                
                for (const docSnapshot of squadsSnapshot.docs) {
                    await deleteDoc(doc(getSquadsCollectionRef(), docSnapshot.id));
                    deletedSquads++;
                    
                    const progress = 50 + (deletedSquads / squadDocs) * 50;
                    updateProgress(progress, `Cancellazione info squadre...`, deletedSquads, squadDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellate ${deletedPlayers} calciatori e ${deletedSquads} squadre.`);
                console.log(`Rose cancellate: ${deletedPlayers} calciatori, ${deletedSquads} squadre`);
                
                // Pulisci il container visualizzazione
                const container = document.getElementById('squads-data-container');
                if (container) {
                    container.innerHTML = '<p class="text-gray-500 text-sm">Nessun dato rose caricato.</p>';
                }
            } catch (error) {
                console.error("Errore cancellazione rose:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };

        window.clearPlayerStats = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm('Sei sicuro di voler cancellare TUTTE le statistiche dei calciatori? Questa azione √® irreversibile.')) {
                return;
            }
            
            showProgressBar('Cancellazione Statistiche');
            
            try {
                const statsSnapshot = await getDocs(getPlayerStatsCollectionRef());
                const totalDocs = statsSnapshot.docs.length;
                let deletedCount = 0;
                
                updateProgress(0, 'Cancellazione statistiche in corso...');
                
                for (const docSnapshot of statsSnapshot.docs) {
                    await deleteDoc(doc(getPlayerStatsCollectionRef(), docSnapshot.id));
                    deletedCount++;
                    
                    const progress = (deletedCount / totalDocs) * 100;
                    updateProgress(progress, `Cancellazione statistiche...`, deletedCount, totalDocs);
                }
                
                hideProgressBar();
                messageBox(`Cancellate ${deletedCount} statistiche calciatori.`);
                console.log(`Cancellate ${deletedCount} statistiche`);
                
                // Pulisci il container visualizzazione
                const summaryContainer = document.getElementById('stats-summary-container');
                if (summaryContainer) {
                    summaryContainer.innerHTML = '';
                }
                const dataContainer = document.getElementById('stats-data-container');
                if (dataContainer) {
                    dataContainer.innerHTML = '<p class="text-gray-500 text-sm">Nessuna statistica caricata.</p>';
                }
            } catch (error) {
                console.error("Errore cancellazione statistiche:", error);
                hideProgressBar();
                messageBox(`Errore durante la cancellazione: ${error.message}`);
            }
        };


        // --- Gestione Caricamento File CSV ---

        // Mappatura date Serie A 2025/2026 - Il fantacalcio parte dalla giornata 3
        const getSerieAMatchDate = (fantaGiornata) => {
            // Mappa: giornata fantacalcio -> giornata Serie A
            // Fantacalcio giornata 1 = Serie A giornata 3
            // Fantacalcio giornata 36 = Serie A giornata 38
            const serieAGiornata = parseInt(fantaGiornata) + 2;
            
            // Date inizio giornate Serie A 2025/2026 (da calendario ufficiale)
            const serieADates = {
                1: '2025-08-23',   // Giornata 1 (23-24 agosto)
                2: '2025-08-29',   // Giornata 2 (29-30 agosto)
                3: '2025-09-13',   // Giornata 3 (13-14 settembre) - INIZIO FANTACALCIO (Fanta G.1)
                4: '2025-09-19',   // Giornata 4 (19-20 settembre) - Fanta G.2
                5: '2025-09-27',   // Giornata 5 (27-28 settembre) - Fanta G.3
                6: '2025-10-03',   // Giornata 6 (3-4 ottobre) - Fanta G.4
                7: '2025-10-18',   // Giornata 7 (18-19 ottobre) - Fanta G.5
                8: '2025-10-24',   // Giornata 8 (24-25 ottobre) - Fanta G.6
                9: '2025-10-28',   // Giornata 9 (28-29 ottobre) - Fanta G.7
                10: '2025-11-01',  // Giornata 10 (1-2 novembre) - Fanta G.8
                11: '2025-11-07',  // Giornata 11 (7-8 novembre) - Fanta G.9
                12: '2025-11-22',  // Giornata 12 (22-23 novembre) - Fanta G.10
                13: '2025-11-28',  // Giornata 13 (28-29 novembre) - Fanta G.11
                14: '2025-12-06',  // Giornata 14 (6-7 dicembre) - Fanta G.12
                15: '2025-12-12',  // Giornata 15 (12-13 dicembre) - Fanta G.13
                16: '2025-12-20',  // Giornata 16 (20-21 dicembre) - Fanta G.14
                17: '2025-12-27',  // Giornata 17 (27-28 dicembre) - Fanta G.15
                18: '2026-01-02',  // Giornata 18 (2-3 gennaio) - Fanta G.16
                19: '2026-01-06',  // Giornata 19 (6-7 gennaio) - Fanta G.17
                20: '2026-01-10',  // Giornata 20 (10-11 gennaio) - Fanta G.18
                21: '2026-01-16',  // Giornata 21 (16-17 gennaio) - Fanta G.19
                22: '2026-01-23',  // Giornata 22 (23-24 gennaio) - Fanta G.20
                23: '2026-02-01',  // Giornata 23 (1-2 febbraio) - Fanta G.21
                24: '2026-02-08',  // Giornata 24 (8-9 febbraio) - Fanta G.22
                25: '2026-02-25',  // Giornata 25 (25-26 febbraio) - Fanta G.23
                26: '2026-02-22',  // Giornata 26 (22-23 febbraio) - Fanta G.24
                27: '2026-03-01',  // Giornata 27 (1-2 marzo) - Fanta G.25
                28: '2026-03-08',  // Giornata 28 (8-9 marzo) - Fanta G.26
                29: '2026-03-15',  // Giornata 29 (15-16 marzo) - Fanta G.27
                30: '2026-03-22',  // Giornata 30 (22-23 marzo) - Fanta G.28
                31: '2026-04-04',  // Giornata 31 (4-5 aprile) - Fanta G.29
                32: '2026-04-12',  // Giornata 32 (12-13 aprile) - Fanta G.30
                33: '2026-04-19',  // Giornata 33 (19-20 aprile) - Fanta G.31
                34: '2026-04-26',  // Giornata 34 (26-27 aprile) - Fanta G.32
                35: '2026-05-03',  // Giornata 35 (3-4 maggio) - Fanta G.33
                36: '2026-05-10',  // Giornata 36 (10-11 maggio) - Fanta G.34
                37: '2026-05-17',  // Giornata 37 (17-18 maggio) - Fanta G.35
                38: '2026-05-24'   // Giornata 38 (24-25 maggio) - Fanta G.36
            };
            
            return serieADates[serieAGiornata] || new Date().toISOString().split('T')[0];
        };

        // --- Gestione Orari Giornate (Schedule Management) ---
        
        // Reference alla collection degli orari delle giornate
        const getScheduleCollectionRef = () => collection(db, 'giornate_schedule');
        
        // Cache per gli orari delle giornate (evita troppe letture da Firestore)
        let scheduleCache = null;
        
        // Carica tutti gli orari delle giornate (con cache)
        const loadAllSchedules = async () => {
            if (scheduleCache) return scheduleCache;
            
            try {
                const snapshot = await getDocs(getScheduleCollectionRef());
                scheduleCache = {};
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    scheduleCache[data.giornata] = data;
                });
                console.log('Schedule cache caricata:', scheduleCache);
                return scheduleCache;
            } catch (error) {
                console.error('Errore caricamento schedules:', error);
                return {};
            }
        };
        
        // Ottieni l'orario di una specifica giornata
        const getGiornataSchedule = async (giornata) => {
            const allSchedules = await loadAllSchedules();
            
            if (allSchedules[giornata]) {
                return allSchedules[giornata];
            }
            
            // Se non esiste, restituisci default
            return getDefaultSchedule(giornata);
        };
        
        // Orario di default per una giornata (se non configurato dall'admin)
        const getDefaultSchedule = (giornata) => {
            // Usa la data dal calendario Serie A
            const date = getSerieAMatchDate(giornata);
            
            // Default: Venerd√¨ sera alle 20:45 (orario "sicuro" per chiusura anticipata)
            // Questo garantisce che le scommesse si chiudano PRIMA dell'eventuale anticipo
            return {
                giornata: giornata.toString(),
                date: date,
                time: '20:45',
                confirmed: false, // Non confermato = orario stimato
                notes: 'Orario di default (non ancora confermato)'
            };
        };
        
        // Calcola la deadline (data + ora) per una giornata
        const getGiornataDeadline = async (giornata) => {
            const schedule = await getGiornataSchedule(giornata);
            
            // Combina data e ora in un oggetto Date
            const deadlineString = `${schedule.date}T${schedule.time}:00`;
            const deadline = new Date(deadlineString);
            
            return {
                deadline: deadline,
                confirmed: schedule.confirmed,
                notes: schedule.notes
            };
        };
        
        // Verifica se la deadline √® passata
        const isDeadlinePassed = async (giornata) => {
            const { deadline } = await getGiornataDeadline(giornata);
            return new Date() >= deadline;
        };

            const processCsvContent = async (csvContent) => {
            if (!isUserAdmin) return;

            console.log('Inizio processamento CSV');
            showProgressBar('Importazione CSV');
            updateProgress(0, 'Lettura file CSV...');

            const delimiter = ';';
            const lines = csvContent.split('\n');
            
            if (lines.length < 2) {
                hideProgressBar();
                messageBox("Il file CSV √® troppo corto o non contiene dati (intestazione mancante).");
                return;
            }

            console.log('CSV letto:', {
                numeroLinee: lines.length,
                primeLinee: lines.slice(0, 5)
            });

            const teamNames = new Set();
            const resultsBatch = []; // Partite giocate
            const matchesBatch = []; // Partite da aprire (score = '-')
            const resultsCollectionRef = getResultsCollectionRef();
            parsedCsvData = []; // Reset data

            console.log('Inizio processamento CSV:', {
                totaleRighe: lines.length,
                primoPaio: lines.slice(0, 2)
            });

            updateProgress(10, 'Analisi righe CSV...');

            // Loop a partire dalla riga 2 (indice 1) per saltare l'intestazione
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Aggiorna progresso durante il parsing
                const parseProgress = 10 + ((i / lines.length) * 20);
                if (i % 10 === 0) { // Aggiorna ogni 10 righe per non rallentare
                    updateProgress(parseProgress, `Elaborazione riga ${i}/${lines.length}...`);
                }

                // Usa il delimitatore punto e virgola
                const columns = line.split(delimiter); 
                
                // Tracciato: [0]Giornata; [1]Casa; [2]P.Casa; [3]P.Ospite; [4]Ospite; [5]Risultato
                if (columns.length < 6) {
                    console.warn(`Riga ${i+1} ignorata: meno di 6 colonne. Contenuto: ${line}`);
                    continue; 
                }

                // Estrazione dati dal nuovo tracciato
                const rawGiornata = columns[0] ? columns[0].trim() : null;
                const homeTeam = columns[1] ? columns[1].trim() : null;
                const homePoints = columns[2] ? parseFloat(columns[2].trim()) : 0; // P.Casa
                const awayPoints = columns[3] ? parseFloat(columns[3].trim()) : 0; // P.Ospite
                const awayTeam = columns[4] ? columns[4].trim() : null;
                const score = columns[5] ? columns[5].trim() : null; // Colonna 'Risultato' (es. "1-1", "3-2", "-")
                
                // Mappa la giornata fantacalcio alla data corrispondente della Serie A
                const date = getSerieAMatchDate(rawGiornata);

                if (rawGiornata && homeTeam && awayTeam) {
                    
                    teamNames.add(homeTeam);
                    teamNames.add(awayTeam);
                    
                    let result = null;
                    let finalScore = null;

                    if (score && score.includes('-') && score !== '-') {
                        // PARTITA GIOCATA (risultato storico)
                        finalScore = score;
                        const [homeGoals, awayGoals] = score.split('-').map(g => parseInt(g.trim(), 10));
                        
                        if (homeGoals > awayGoals) {
                            result = '1';
                        } else if (homeGoals < awayGoals) {
                            result = '2';
                        } else {
                            result = 'X';
                        }
                        
                        const resultData = {
                            homeTeam,
                            awayTeam,
                            homePoints,  // Aggiungi punteggio casa
                            awayPoints,  // Aggiungi punteggio ospite
                            result,
                            score: finalScore,
                            date, 
                            giornata: rawGiornata,
                            status: 'closed'  // Aggiungiamo lo status closed
                        };
                        resultsBatch.push(resultData);
                        parsedCsvData.push(resultData);

                    } else if (score === '-') {
                        // PARTITA DA APRIRE (prossimo match)
                        console.log('Trovata partita da aprire:', {
                            homeTeam,
                            awayTeam,
                            giornata: rawGiornata,
                            score
                        });
                        
                        const odds = calculateOdds(homeTeam, awayTeam);
                        console.log('Quote calcolate:', {
                            partita: `${homeTeam} vs ${awayTeam}`,
                            odds
                        });
                        
                        const matchData = {
                            homeTeam,
                            awayTeam,
                            date,
                            giornata: rawGiornata,
                            status: 'open',
                            score: null,
                            odds: odds  // Aggiungiamo le quote
                        };
                        matchesBatch.push(matchData);
                        parsedCsvData.push(matchData);
                        
                        console.log('Aggiunta partita al batch:', matchData);
                    }
                }
            }
            
            // 1. Salva le Squadre
            updateProgress(30, `Salvataggio squadre (${teamNames.size})...`);
            let teamCount = 0;
            for (const team of teamNames) {
                if (team) {
                    await addTeamToFirestore(team);
                    teamCount++;
                    const teamProgress = 30 + ((teamCount / teamNames.size) * 10);
                    updateProgress(teamProgress, `Salvataggio squadre...`, teamCount, teamNames.size);
                }
            }

            // 2. Salva i Risultati Storici (Partite Giocate)
            updateProgress(40, `Salvataggio risultati storici (${resultsBatch.length})...`);
            let savedResultsCount = 0;
            for (const res of resultsBatch) {
                 const q = query(getResultsCollectionRef(), 
                     where('homeTeam', '==', res.homeTeam),
                     where('awayTeam', '==', res.awayTeam),
                     where('giornata', '==', res.giornata), 
                     limit(1)
                 );
                 const existingDocs = await getDocs(q);
                 if (existingDocs.empty) {
                     await addDoc(resultsCollectionRef, res);
                     savedResultsCount++;
                 }
                 
                 if (resultsBatch.length > 0) {
                     const resultProgress = 40 + ((savedResultsCount / resultsBatch.length) * 20);
                     updateProgress(resultProgress, `Salvataggio risultati...`, savedResultsCount, resultsBatch.length);
                 }
            }
            
            // 3. Salva le Partite Future (Partite Aperte)
            updateProgress(60, 'Pulizia partite aperte precedenti...');
            let savedMatchesCount = 0;
            const matchesCollectionRef = getMatchesCollectionRef();

            // Prima elimina tutte le partite aperte esistenti
            console.log('Rimozione partite aperte esistenti...');
            const openMatchesQuery = query(matchesCollectionRef, where('status', '==', 'open'));
            const openMatchesSnapshot = await getDocs(openMatchesQuery);
            const batch = writeBatch(db);
            openMatchesSnapshot.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            console.log(`${openMatchesSnapshot.size} partite aperte rimosse`);

            // Ora salva le nuove partite aperte
            updateProgress(65, `Salvataggio nuove partite (${matchesBatch.length})...`);
            console.log(`Salvataggio ${matchesBatch.length} nuove partite aperte...`);
            for (const match of matchesBatch) {
                // Calcola le quote usando tutti i risultati storici
                const odds = calculateOdds(match.homeTeam, match.awayTeam);
                
                await addDoc(matchesCollectionRef, {
                    ...match,
                    odds: odds,
                    status: 'open', // Assicurati che lo status sia impostato
                    createdAt: new Date().toISOString()
                });
                savedMatchesCount++;
                
                const matchProgress = 65 + ((savedMatchesCount / matchesBatch.length) * 15);
                updateProgress(matchProgress, `Salvataggio partite...`, savedMatchesCount, matchesBatch.length);
                console.log(`Salvata partita: ${match.homeTeam} vs ${match.awayTeam} (Giornata ${match.giornata})`);
            }

            // 4. Liquida le scommesse per le giornate completate
            updateProgress(80, 'Preparazione liquidazione scommesse...');
            
            // FLAG: Imposta a false per disabilitare temporaneamente la liquidazione automatica
            const ENABLE_AUTO_LIQUIDATION = true;
            
            // Raggruppa i risultati per giornata
            const resultsByGiornata = new Map();
            resultsBatch.forEach(res => {
                const giornataNum = res.giornata.toString().match(/\d+/)?.[0] || res.giornata;
                if (!resultsByGiornata.has(giornataNum)) {
                    resultsByGiornata.set(giornataNum, []);
                }
                resultsByGiornata.get(giornataNum).push(res);
            });

            // Liquida le scommesse per ogni giornata con risultati
            let totalSettled = 0;
            let totalWinners = 0;
            let totalLosers = 0;
            
            const giornateCount = resultsByGiornata.size;
            let processedGiornate = 0;
            
            console.log(`Giornate da liquidare: ${giornateCount}`);
            console.log(`Liquidazione automatica: ${ENABLE_AUTO_LIQUIDATION ? 'ABILITATA' : 'DISABILITATA'}`);
            
            if (ENABLE_AUTO_LIQUIDATION && giornateCount > 0) {
                console.log(`Inizio liquidazione per ${giornateCount} giornate...`);
            
                try {
                    for (const [giornata, results] of resultsByGiornata) {
                        processedGiornate++;
                        const liquidationProgress = 80 + ((processedGiornate / giornateCount) * 15);
                        updateProgress(liquidationProgress, `Liquidazione Giornata ${giornata}...`, processedGiornate, giornateCount);
                        
                        console.log(`[${processedGiornate}/${giornateCount}] Liquidazione Giornata ${giornata} con ${results.length} risultati`);
                        
                        try {
                            const settlement = await Promise.race([
                                liquidateBetsForGiornata(giornata, results),
                                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout liquidazione')), 30000))
                            ]);
                            
                            totalSettled += settlement.processed;
                            totalWinners += settlement.winners;
                            totalLosers += settlement.losers;
                            console.log(`Giornata ${giornata} liquidata: ${settlement.processed} scommesse`);
                        } catch (liquidationError) {
                            console.error(`Errore liquidazione Giornata ${giornata}:`, liquidationError);
                            // Continua comunque con le altre giornate
                        }
                    }
                } catch (error) {
                    console.error('Errore generale durante la liquidazione:', error);
                }
            } else {
                console.log('Liquidazione saltata (disabilitata o nessuna giornata da liquidare)');
                updateProgress(95, 'Saltata liquidazione...');
            }

            console.log('Liquidazione completata, finalizzazione...');
            updateProgress(95, 'Finalizzazione...');
            
            // Forza un piccolo delay per permettere all'UI di aggiornarsi
            await new Promise(resolve => setTimeout(resolve, 100));
            
            renderCsvData(parsedCsvData);

            updateProgress(100, 'Completato!');
            
            let message = `Importazione completata: salvate ${teamNames.size} squadre uniche. Risultati storici: ${savedResultsCount}. Partite future aperte: ${savedMatchesCount}.`;
            
            if (totalSettled > 0) {
                message += `\n\nLiquidazione scommesse: ${totalSettled} scommesse processate (${totalWinners} vincenti, ${totalLosers} perdenti).`;
            } else if (resultsByGiornata.size > 0) {
                message += `\n\nNessuna scommessa da liquidare trovata per queste giornate.`;
            }
            
            console.log('Processo completato!');
            
            setTimeout(() => {
                hideProgressBar();
                messageBox(message);
            }, 500);
        };

        const renderCsvData = (data) => {
            const container = document.getElementById('csv-data-container');
            if (!container) return;

            if (!data || data.length === 0) {
                container.innerHTML = '<p class="text-gray-500">Nessun dato da visualizzare. Carica un file CSV.</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'min-w-full bg-gray-800 rounded-lg overflow-hidden';

            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr class="bg-gray-700 text-gray-400">
                    <th class="px-4 py-2 text-left">Giornata</th>
                    <th class="px-4 py-2 text-left">Data</th>
                    <th class="px-4 py-2 text-left" colspan="2">Squadra Casa</th>
                    <th class="px-4 py-2 text-left" colspan="2">Squadra Ospite</th>
                    <th class="px-4 py-2 text-left">Risultato/Status</th>
                    <th class="px-4 py-2 text-left">Punteggio</th>
                </tr>
            `;
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            tbody.className = 'text-gray-300';

            data.forEach(row => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-700 border-b border-gray-700';
                tr.innerHTML = `
                    <td class="px-4 py-3 whitespace-nowrap text-sm">${row.giornata}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">${row.date}</td>
                    <td class="px-2 py-3 text-center"><img src="${getTeamLogo(row.homeTeam)}" alt="${row.homeTeam}" class="w-8 h-8 object-contain mx-auto" onerror="this.style.display='none'"></td>
                    <td class="px-2 py-3 whitespace-nowrap text-sm font-semibold">${row.homeTeam}</td>
                    <td class="px-2 py-3 text-center"><img src="${getTeamLogo(row.awayTeam)}" alt="${row.awayTeam}" class="w-8 h-8 object-contain mx-auto" onerror="this.style.display='none'"></td>
                    <td class="px-2 py-3 whitespace-nowrap text-sm font-semibold">${row.awayTeam}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">${row.result || row.status}</td>
                    <td class="px-4 py-3 whitespace-nowrap text-sm">${row.score || '-'}</td>
                `;
                tbody.appendChild(tr);
            });

            table.appendChild(tbody);
            container.innerHTML = '';
            container.appendChild(table);
        };

        // Funzione per liquidare le scommesse di una giornata completata
        const liquidateBetsForGiornata = async (giornata, results) => {
            console.log(`=== INIZIO LIQUIDAZIONE GIORNATA ${giornata} ===`);
            
            try {
                // 1. Recupera tutte le scommesse per questa giornata
                const betsQuery = query(
                    getGiornataBetsCollectionRef(),
                    where('giornata', '==', giornata.toString())
                );
                const betsSnapshot = await getDocs(betsQuery);
                
                console.log(`Scommesse trovate per Giornata ${giornata}: ${betsSnapshot.size}`);
                
                if (betsSnapshot.empty) {
                    return { processed: 0, winners: 0, losers: 0 };
                }
                
                // 2. Crea una mappa dei risultati effettivi per rapido accesso
                const resultsMap = new Map();
                results.forEach(res => {
                    const key = `${res.homeTeam}_${res.awayTeam}`;
                    resultsMap.set(key, res.result);
                });

                let processedCount = 0;
                let winnersCount = 0;
                let losersCount = 0;

                // Batch per aggiornamenti crediti utenti
                const userUpdates = new Map();

                // 3. Processa ogni scommessa
                for (const betDoc of betsSnapshot.docs) {
                    const bet = betDoc.data();
                    
                    // Verifica se la scommessa √® gi√† stata liquidata
                    if (bet.settled) {
                        console.log(`Scommessa ${betDoc.id} gi√† liquidata, skip`);
                        continue;
                    }

                    let correctPredictions = 0;
                    let totalPredictions = 0;
                    const detailedResults = [];

                    // 4. Verifica ogni pronostico della scommessa
                    bet.predictions.forEach(pred => {
                        const key = `${pred.homeTeam}_${pred.awayTeam}`;
                        const actualResult = resultsMap.get(key);
                        
                        if (actualResult) {
                            totalPredictions++;
                            const isCorrect = pred.prediction === actualResult;
                            if (isCorrect) correctPredictions++;
                            
                            detailedResults.push({
                                match: `${pred.homeTeam} vs ${pred.awayTeam}`,
                                predicted: pred.prediction,
                                actual: actualResult,
                                correct: isCorrect
                            });
                        }
                    });

                    // 5. Calcola se la scommessa √® vincente (tutti i pronostici corretti)
                    const isWinningBet = totalPredictions > 0 && correctPredictions === totalPredictions;
                    
                    // 6. Calcola la vincita (usa quotaTotale moltiplicativa, non quotaMedia)
                    let winnings = 0;
                    if (isWinningBet) {
                        winnings = bet.stake * bet.quotaTotale;
                        winnersCount++;
                    } else {
                        winnings = 0;
                        losersCount++;
                    }

                    // 7. Accumula aggiornamenti crediti (faremo batch update dopo)
                    if (winnings > 0) {
                        if (!userUpdates.has(bet.userId)) {
                            userUpdates.set(bet.userId, 0);
                        }
                        userUpdates.set(bet.userId, userUpdates.get(bet.userId) + winnings);
                    }

                    // 8. Marca la scommessa come liquidata
                    await updateDoc(betDoc.ref, {
                        settled: true,
                        settledAt: new Date().toISOString(),
                        isWinning: isWinningBet,
                        winnings: winnings,
                        correctPredictions: correctPredictions,
                        totalPredictions: totalPredictions,
                        detailedResults: detailedResults
                    });

                    processedCount++;
                }

                // 9. Aggiorna crediti utenti in batch
                console.log(`Aggiornamento crediti per ${userUpdates.size} utenti...`);
                const usersCollectionRef = getUsersCollectionRef();
                
                for (const [userId, creditToAdd] of userUpdates) {
                    const userQuery = query(usersCollectionRef, where('uid', '==', userId));
                    const userSnapshot = await getDocs(userQuery);
                    
                    if (!userSnapshot.empty) {
                        const userDoc = userSnapshot.docs[0];
                        const currentCredits = userDoc.data().credits || 0;
                        const newCredits = currentCredits + creditToAdd;
                        
                        await updateDoc(userDoc.ref, {
                            credits: newCredits
                        });
                        
                        console.log(`Utente ${userId}: +${creditToAdd.toFixed(2)} crediti (${currentCredits} ‚Üí ${newCredits})`);
                    }
                }

                console.log(`=== FINE LIQUIDAZIONE GIORNATA ${giornata} ===`);
                console.log(`Processate: ${processedCount}, Vincenti: ${winnersCount}, Perdenti: ${losersCount}`);

                return { processed: processedCount, winners: winnersCount, losers: losersCount };

            } catch (error) {
                console.error('Errore durante la liquidazione delle scommesse:', error);
                throw error;
            }
        };
        
        window.handleFileSelect = () => {
            console.log('handleFileSelect chiamato');
            const fileInput = document.getElementById('csv-file-input');
            console.log('Input file trovato:', !!fileInput);
            
            const file = fileInput?.files[0];
            console.log('File selezionato:', file ? {
                nome: file.name,
                tipo: file.type,
                dimensione: file.size
            } : 'nessun file');
            
            const fileNameDisplay = document.getElementById('file-name-display');
            const uploadButton = document.getElementById('upload-button');
            
            console.log('Elementi UI trovati:', {
                fileNameDisplay: !!fileNameDisplay,
                uploadButton: !!uploadButton
            });

            if (file) {
                if (fileNameDisplay) fileNameDisplay.textContent = file.name;
                if (uploadButton) {
                    uploadButton.disabled = false;
                    uploadButton.classList.remove('btn-secondary');
                    uploadButton.classList.add('btn-primary');
                }
                console.log('File selezionato correttamente, UI aggiornata');
            } else {
                if (fileNameDisplay) fileNameDisplay.textContent = 'Nessun file selezionato.';
                if (uploadButton) {
                    uploadButton.disabled = true;
                    uploadButton.classList.add('btn-secondary');
                    uploadButton.classList.remove('btn-primary');
                }
                console.log('Nessun file selezionato, UI resettata');
            }
        }

        window.confirmUpload = async () => {
            console.log('confirmUpload chiamato');
            
            if (!isUserAdmin) {
                console.warn('Tentativo di upload da utente non admin');
                messageBox("Solo gli admin possono caricare file.");
                return;
            }

            const fileInput = document.getElementById('csv-file-input');
            const file = fileInput?.files[0];
            
            console.log('Stato file:', {
                inputTrovato: !!fileInput,
                fileTrovato: !!file,
                dettagliFile: file ? {
                    nome: file.name,
                    tipo: file.type,
                    dimensione: file.size
                } : null
            });

            if (!file) {
                messageBox("Seleziona un file prima di caricarlo.");
                return;
            }

            try {
                // Check if data already exists
                console.log('Verifica dati esistenti...');
                const q = query(getResultsCollectionRef(), limit(1));
                const snapshot = await getDocs(q);
                console.log('Snapshot risultati:', {
                    vuoto: snapshot.empty,
                    numeroDoc: snapshot.size
                });
                
                let confirmationMessage = "Sei sicuro di voler caricare il file? Eventuali dati esistenti verranno sovrascritti.";

                if (snapshot.empty) {
                    confirmationMessage = "Sei sicuro di voler procedere con il caricamento del file?";
                }

                console.log('Richiesta conferma utente');
                if (confirm(confirmationMessage)) {
                    console.log('Utente ha confermato, avvio processamento');
                    processNewFile();
                } else {
                    console.log('Utente ha annullato');
                }
            } catch (error) {
                console.error('Errore durante la verifica dei dati esistenti:', error);
                messageBox("Errore durante la verifica dei dati: " + error.message);
            }
        }

        window.processNewFile = () => {
            console.log('processNewFile chiamato');
            if (!isUserAdmin) {
                console.warn('Utente non admin, caricamento non permesso');
                return;
            }
            
            const fileInput = document.getElementById('csv-file-input');
            console.log('File input trovato:', !!fileInput);
            
            const file = fileInput.files[0];
            console.log('File selezionato:', file ? {
                nome: file.name,
                tipo: file.type,
                dimensione: file.size
            } : 'nessun file');
            
            const fileNameDisplay = document.getElementById('file-name-display');
            console.log('Display elemento trovato:', !!fileNameDisplay);

            if (!file) {
                if (fileNameDisplay) fileNameDisplay.textContent = 'Nessun file selezionato.';
                console.warn('Nessun file selezionato');
                return;
            }

            if (fileNameDisplay) fileNameDisplay.textContent = file.name;

            const reader = new FileReader();
            reader.onload = async (e) => {
                console.log('File letto con successo');
                localCsvContent = e.target.result;
                console.log('Contenuto CSV (primi 200 caratteri):', localCsvContent.substring(0, 200));
                try {
                    await processCsvContent(localCsvContent);
                } catch (error) {
                    console.error('Errore durante il processamento del CSV:', error);
                    messageBox("Errore durante l'elaborazione del file: " + error.message);
                }
            };
            reader.onerror = (error) => {
                console.error('Errore nella lettura del file:', error);
                messageBox("Errore nella lettura del file: " + error);
            };
            
            console.log('Inizio lettura file...');
            reader.readAsText(file);
        };
        
        window.processUploadedData = async (fileName) => {
             if (!isUserAdmin) return;
             // Se non ho ancora caricato localCsvContent dal file picker, 
             // cerco di recuperare il contenuto dal file pre-caricato dell'ambiente
             if (!localCsvContent) {
                 if (typeof __file_contents !== 'undefined' && __file_contents[fileName]) {
                     localCsvContent = __file_contents[fileName];
                 } else {
                     messageBox(`Il contenuto del file "${fileName}" non √® disponibile per l'auto-caricamento. Carica il file manualmente.`);
                     return;
                 }
             }
             
             await processCsvContent(localCsvContent); 
        };

        const loadInitialData = async () => {
            if (!isUserAdmin) return;
            try {
                // Controlla se esistono gi√† risultati storici
                const q = query(getResultsCollectionRef(), limit(1));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    // Simula il caricamento del file pre-caricato
                    await processUploadedData('Calendario_Campionato.csv');
                    messageBox("Caricamento automatico dei risultati storici e del calendario completato.");
                }
            } catch (error) {
                console.error("Errore nel caricamento iniziale dei dati:", error);
            }
        };

        // --- Gestione Quote e Partite ---

        // Helper: determina l'ultima giornata completata usando SIA i match chiusi SIA i risultati storici
        const determineLastCompletedGiornata = () => {
            // Dal registro partite (solo match chiusi con result)
            const fromMatches = (allMatches || [])
                .filter(m => m && m.status === 'closed' && m.result)
                .reduce((max, m) => {
                    const g = parseInt(m.giornata || '0', 10) || 0;
                    return g > max ? g : max;
                }, 0);

            // Dai risultati storici importati (CSV)
            const fromResults = (allResults || [])
                .reduce((max, r) => {
                    // Estrai il numero dalla stringa giornata (es. "7", "Giornata 7", etc.)
                    const match = (r.giornata || '').toString().match(/\d+/);
                    const g = match ? parseInt(match[0], 10) || 0 : 0;
                    return g > max ? g : max;
                }, 0);

            const last = Math.max(fromMatches, fromResults);
            console.log('determineLastCompletedGiornata ->', { fromMatches, fromResults, last });
            return last;
        };

        const updateMatchToCloseSelect = (matches) => {
            const select = document.getElementById('match-to-close-select');
            if (!select) return; 
            
            // Trova l'ultima giornata con risultati (usa anche i risultati storici)
            const lastCompletedGiornata = determineLastCompletedGiornata();
            console.log('updateMatchToCloseSelect -> ultima completata:', lastCompletedGiornata, 'prossima:', lastCompletedGiornata + 1);

                // Mostra solo le partite della prossima giornata da completare
                const openMatches = matches
                    .filter(m => {
                        const giornata = parseInt(m.giornata || '0', 10);
                        const isNextGiornata = giornata === (lastCompletedGiornata + 1);
                        const isOpen = m.status === 'open' || !m.status;
                        
                        console.log('Valutazione partita per visualizzazione:', {
                            partita: `${m.homeTeam} vs ${m.awayTeam}`,
                            giornata,
                            status: m.status,
                            isNextGiornata,
                            isOpen,
                            include: isOpen && isNextGiornata
                        });
                        
                        return isOpen && isNextGiornata;
                    })
                    .sort((a, b) => new Date(a.date) - new Date(b.date));

            select.innerHTML = '<option value="">Seleziona partita da chiudere</option>';
            
            if (openMatches.length === 0) {
                 select.innerHTML = '<option value="">Nessuna partita aperta nella prossima giornata</option>';
                 return;
            }

            openMatches.forEach(match => {
                const option = document.createElement('option');
                option.value = match.id;
                option.textContent = `G${match.giornata}: ${match.homeTeam} vs ${match.awayTeam} (${match.date})`;
                select.appendChild(option);
            });
        };

        // --- Gestione Caricamento Rose da CSV ---
        
        window.triggerSquadsFileInput = () => {
            document.getElementById('squads-csv-file-input').click();
        };

        window.handleSquadsFileSelect = () => {
            const fileInput = document.getElementById('squads-csv-file-input');
            const file = fileInput?.files[0];
            
            const fileNameDisplay = document.getElementById('squads-file-name-display');
            const uploadButton = document.getElementById('upload-squads-button');

            if (file) {
                if (fileNameDisplay) fileNameDisplay.textContent = file.name;
                if (uploadButton) {
                    uploadButton.disabled = false;
                    uploadButton.classList.remove('btn-secondary');
                    uploadButton.classList.add('btn-primary');
                }
            } else {
                if (fileNameDisplay) fileNameDisplay.textContent = 'Nessun file selezionato.';
                if (uploadButton) {
                    uploadButton.disabled = true;
                    uploadButton.classList.add('btn-secondary');
                    uploadButton.classList.remove('btn-primary');
                }
            }
        };

        window.confirmSquadsUpload = async () => {
            if (!isUserAdmin) {
                messageBox("Solo gli admin possono caricare le rose.");
                return;
            }

            const fileInput = document.getElementById('squads-csv-file-input');
            const file = fileInput?.files[0];

            if (!file) {
                messageBox("Seleziona un file prima di caricarlo.");
                return;
            }

            if (confirm("Sei sicuro di voler caricare le rose? I dati esistenti verranno sovrascritti.")) {
                processSquadsFile();
            }
        };

        window.processSquadsFile = async () => {
            if (!isUserAdmin) return;

            const fileInput = document.getElementById('squads-csv-file-input');
            const file = fileInput?.files[0];

            if (!file) {
                messageBox("Nessun file selezionato.");
                return;
            }

            showProgressBar('Caricamento rose in corso...');

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const text = e.target.result;
                    const lines = text.split('\n').map(line => line.trim()).filter(line => line);
                    
                    if (lines.length === 0) {
                        hideProgressBar();
                        messageBox("Il file CSV √® vuoto.");
                        return;
                    }

                    // Parse CSV: Squadra;Ruolo;Calciatore;Squadra (Serie A);Costo
                    const players = [];
                    const squads = new Map(); // squadra -> array di giocatori
                    
                    let processedLines = 0;
                    
                    for (const line of lines) {
                        const columns = line.split(';').map(col => col.trim().replace(/^["']|["']$/g, '')); // Rimuove virgolette
                        
                        // Salta righe vuote o incomplete
                        if (columns.length < 5) continue;
                        if (!columns[0] || !columns[1] || !columns[2]) continue;
                        
                        const squadName = columns[0];
                        const role = columns[1];
                        const playerName = columns[2];
                        const serieATeam = columns[3];
                        const cost = parseFloat(columns[4]) || 0;
                        
                        // Salta intestazioni o righe non valide
                        if (role === 'Ruolo' || squadName === 'Squadra') continue;
                        if (!squadName || squadName.includes('Crediti Residui')) continue;
                        
                        const playerData = {
                            squadName: squadName,
                            role: role,
                            playerName: playerName,
                            serieATeam: serieATeam,
                            cost: cost
                        };
                        
                        players.push(playerData);
                        
                        // Raggruppa per squadra
                        if (!squads.has(squadName)) {
                            squads.set(squadName, []);
                        }
                        squads.get(squadName).push(playerData);
                        
                        processedLines++;
                        
                        // Aggiorna progress bar
                        if (processedLines % 10 === 0) {
                            const progress = Math.min(50, (processedLines / lines.length) * 50);
                            updateProgress(progress, `Processate ${processedLines} righe...`);
                        }
                    }
                    
                    console.log('Rose parsate:', { 
                        totaleGiocatori: players.length, 
                        numeroSquadre: squads.size 
                    });
                    
                    updateProgress(50, 'Salvataggio giocatori in corso...');
                    
                    // Salva i giocatori in Firestore
                    const playersCollection = getPlayersCollectionRef();
                    
                    // Prima cancella tutti i giocatori esistenti
                    const existingPlayersSnapshot = await getDocs(playersCollection);
                    const deletePromises = existingPlayersSnapshot.docs.map(doc => deleteDoc(doc.ref));
                    await Promise.all(deletePromises);
                    
                    updateProgress(60, 'Salvataggio nuovi giocatori...');
                    
                    // Salva i nuovi giocatori
                    let savedCount = 0;
                    for (const player of players) {
                        await addDoc(playersCollection, player);
                        savedCount++;
                        
                        if (savedCount % 20 === 0) {
                            const progress = 60 + (savedCount / players.length) * 30;
                            updateProgress(progress, `Salvati ${savedCount}/${players.length} giocatori...`);
                        }
                    }
                    
                    updateProgress(90, 'Salvataggio informazioni squadre...');
                    
                    // Salva le informazioni aggregate per squadra
                    const squadsCollection = getSquadsCollectionRef();
                    
                    // Cancella squadre esistenti
                    const existingSquadsSnapshot = await getDocs(squadsCollection);
                    const deleteSquadsPromises = existingSquadsSnapshot.docs.map(doc => deleteDoc(doc.ref));
                    await Promise.all(deleteSquadsPromises);
                    
                    // Salva nuove squadre
                    for (const [squadName, squadPlayers] of squads.entries()) {
                        const squadData = {
                            name: squadName,
                            playerCount: squadPlayers.length,
                            totalCost: squadPlayers.reduce((sum, p) => sum + p.cost, 0),
                            roles: {
                                P: squadPlayers.filter(p => p.role === 'P').length,
                                D: squadPlayers.filter(p => p.role === 'D').length,
                                C: squadPlayers.filter(p => p.role === 'C').length,
                                A: squadPlayers.filter(p => p.role === 'A').length
                            }
                        };
                        await addDoc(squadsCollection, squadData);
                    }
                    
                    updateProgress(100, 'Completato!');
                    
                    // Mostra riepilogo
                    renderSquadsData(squads);
                    
                    hideProgressBar();
                    messageBox(`Rose caricate con successo!\n\nSquadre: ${squads.size}\nGiocatori totali: ${players.length}`);
                    
                } catch (error) {
                    console.error('Errore durante il processamento del file rose:', error);
                    hideProgressBar();
                    messageBox("Errore durante il caricamento: " + error.message);
                }
            };

            reader.onerror = () => {
                hideProgressBar();
                messageBox("Errore nella lettura del file.");
            };

            reader.readAsText(file, 'UTF-8');
        };

        const renderSquadsData = (squadsMap) => {
            const container = document.getElementById('squads-data-container');
            if (!container) return;
            
            let html = '<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">';
            
            for (const [squadName, players] of squadsMap.entries()) {
                const totalCost = players.reduce((sum, p) => sum + p.cost, 0);
                const roles = {
                    P: players.filter(p => p.role === 'P').length,
                    D: players.filter(p => p.role === 'D').length,
                    C: players.filter(p => p.role === 'C').length,
                    A: players.filter(p => p.role === 'A').length
                };
                
                html += `
                    <div class="bg-gray-800 border border-purple-700/50 rounded-lg p-4">
                        <h5 class="text-lg font-bold text-purple-400 mb-2">${squadName}</h5>
                        <div class="text-sm text-gray-300 space-y-1">
                            <p>Giocatori: <span class="font-bold">${players.length}</span></p>
                            <p>Costo totale: <span class="font-bold text-yellow-400">${totalCost}</span></p>
                            <div class="flex justify-between mt-2 pt-2 border-t border-gray-700">
                                <span>P: ${roles.P}</span>
                                <span>D: ${roles.D}</span>
                                <span>C: ${roles.C}</span>
                                <span>A: ${roles.A}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
        };

        // === FUNZIONI PER LA VISUALIZZAZIONE PUBBLICA DELLE ROSE ===
        
        window.loadSquadsData = async () => {
            try {
                const playersCollection = getPlayersCollectionRef();
                const snapshot = await getDocs(playersCollection);
                
                if (snapshot.empty) {
                    document.getElementById('squads-view-container').innerHTML = '<p class="text-center text-gray-500 py-8">Nessuna rosa caricata. Contatta l\'admin per il caricamento.</p>';
                    return;
                }
                
                // Raggruppa i giocatori per squadra
                const squadsMap = new Map();
                snapshot.forEach(doc => {
                    const player = doc.data();
                    if (!squadsMap.has(player.squadName)) {
                        squadsMap.set(player.squadName, []);
                    }
                    squadsMap.get(player.squadName).push(player);
                });
                
                // Popola il filtro squadre
                const filterSelect = document.getElementById('squad-filter');
                filterSelect.innerHTML = '<option value="all">Tutte le squadre</option>';
                Array.from(squadsMap.keys()).sort().forEach(squadName => {
                    filterSelect.innerHTML += `<option value="${squadName}">${squadName}</option>`;
                });
                
                // Salva i dati globalmente per il filtro
                window.currentSquadsData = squadsMap;
                
                // Mostra tutte le squadre
                renderSquadsView(squadsMap);
                
            } catch (error) {
                console.error('Errore nel caricamento delle rose:', error);
                messageBox('Errore nel caricamento delle rose.');
            }
        };
        
        const renderSquadsView = (squadsMap) => {
            const container = document.getElementById('squads-view-container');
            if (!container) return;
            
            let html = '<div class="space-y-6">';
            
            // Ordina le squadre alfabeticamente
            const sortedSquads = Array.from(squadsMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
            
            for (const [squadName, players] of sortedSquads) {
                const totalCost = players.reduce((sum, p) => sum + p.cost, 0);
                const roles = {
                    P: players.filter(p => p.role === 'P'),
                    D: players.filter(p => p.role === 'D'),
                    C: players.filter(p => p.role === 'C'),
                    A: players.filter(p => p.role === 'A')
                };
                
                html += `
                    <div class="bg-gray-800 border border-purple-700/50 rounded-lg overflow-hidden">
                        <!-- Header squadra -->
                        <div class="bg-gradient-to-r from-purple-900 to-purple-800 p-4 border-b border-purple-700">
                            <div class="flex justify-between items-center">
                                <h3 class="text-xl font-bold text-white">${squadName}</h3>
                                <div class="text-right">
                                    <p class="text-sm text-purple-200">Giocatori: <span class="font-bold">${players.length}</span></p>
                                    <p class="text-sm text-yellow-300">Crediti: <span class="font-bold">${totalCost}</span></p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Giocatori per ruolo -->
                        <div class="p-4 space-y-4">
                `;
                
                // Mostra i giocatori per ogni ruolo
                const roleLabels = { P: 'Portieri', D: 'Difensori', C: 'Centrocampisti', A: 'Attaccanti' };
                const roleColors = { P: 'yellow', D: 'blue', C: 'green', A: 'red' };
                
                for (const [roleKey, roleLabel] of Object.entries(roleLabels)) {
                    const rolePlayers = roles[roleKey];
                    if (rolePlayers.length > 0) {
                        const color = roleColors[roleKey];
                        html += `
                            <div>
                                <h4 class="text-sm font-bold text-${color}-400 mb-2 flex items-center">
                                    <span class="inline-block w-6 h-6 rounded-full bg-${color}-900 text-${color}-300 text-center text-xs leading-6 mr-2">${roleKey}</span>
                                    ${roleLabel} (${rolePlayers.length})
                                </h4>
                                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2">
                        `;
                        
                        // Ordina i giocatori per costo decrescente
                        rolePlayers.sort((a, b) => b.cost - a.cost);
                        
                        for (const player of rolePlayers) {
                            html += `
                                <div class="bg-gray-700 rounded px-3 py-2 flex justify-between items-center">
                                    <div>
                                        <p class="text-sm font-medium text-white">${player.playerName}</p>
                                        <p class="text-xs text-gray-400">${player.serieATeam}</p>
                                    </div>
                                    <span class="text-sm font-bold text-yellow-400">${player.cost}</span>
                                </div>
                            `;
                        }
                        
                        html += `
                                </div>
                            </div>
                        `;
                    }
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            
            if (squadsMap.size === 0) {
                html = '<p class="text-center text-gray-500 py-8">Nessuna squadra trovata.</p>';
            }
            
            container.innerHTML = html;
        };
        
        window.filterSquadView = () => {
            const filterValue = document.getElementById('squad-filter').value;
            
            if (!window.currentSquadsData) return;
            
            if (filterValue === 'all') {
                renderSquadsView(window.currentSquadsData);
            } else {
                const filteredMap = new Map();
                if (window.currentSquadsData.has(filterValue)) {
                    filteredMap.set(filterValue, window.currentSquadsData.get(filterValue));
                }
                renderSquadsView(filteredMap);
            }
        };

        // === FINE FUNZIONI ROSE ===

        // === FUNZIONI PER CARICAMENTO STATISTICHE CALCIATORI ===
        
        let selectedStatsFile = null;
        
        window.triggerStatsFileInput = () => {
            document.getElementById('stats-csv-file-input').click();
        };
        
        window.handleStatsFileSelect = () => {
            const fileInput = document.getElementById('stats-csv-file-input');
            const fileNameDisplay = document.getElementById('stats-file-name-display');
            const uploadButton = document.getElementById('upload-stats-button');
            
            if (fileInput.files.length > 0) {
                selectedStatsFile = fileInput.files[0];
                fileNameDisplay.textContent = selectedStatsFile.name;
                uploadButton.disabled = false;
                uploadButton.classList.remove('btn-secondary');
                uploadButton.classList.add('btn-primary');
            } else {
                selectedStatsFile = null;
                fileNameDisplay.textContent = 'Nessun file selezionato.';
                uploadButton.disabled = true;
                uploadButton.classList.remove('btn-primary');
                uploadButton.classList.add('btn-secondary');
            }
        };
        
        window.confirmStatsUpload = () => {
            if (!selectedStatsFile) {
                messageBox('Seleziona un file CSV prima di procedere.');
                return;
            }
            
            if (confirm(`Confermi il caricamento delle statistiche dal file "${selectedStatsFile.name}"?\n\nATTENZIONE: Le statistiche precedenti verranno sovrascritte.`)) {
                processStatsFile();
            }
        };
        
        window.processStatsFile = async () => {
            if (!selectedStatsFile) {
                messageBox('Nessun file selezionato.');
                return;
            }
            
            const uploadButton = document.getElementById('upload-stats-button');
            uploadButton.disabled = true;
            uploadButton.textContent = 'Caricamento...';
            
            try {
                const text = await selectedStatsFile.text();
                const lines = text.split('\n').filter(line => line.trim() !== '');
                
                if (lines.length < 2) {
                    throw new Error('File CSV vuoto o non valido.');
                }
                
                // Parse delle statistiche
                const stats = [];
                const playersCollection = getPlayersCollectionRef();
                const statsCollection = getPlayerStatsCollectionRef();
                
                // Carica tutte le rose per associare i calciatori alle squadre fantacalcio
                updateProgress(0, 'Caricamento rose...', null, null, 'stats-progress');
                const playersSnapshot = await getDocs(playersCollection);
                const playerToSquadMap = new Map(); // Nome calciatore -> Rosa fantacalcio
                
                playersSnapshot.forEach(doc => {
                    const player = doc.data();
                    // Chiave: nome calciatore normalizzato
                    const normalizedName = player.playerName.trim().toLowerCase();
                    playerToSquadMap.set(normalizedName, player.squadName);
                });
                
                console.log(`Rose caricate: ${playerToSquadMap.size} calciatori trovati`);
                
                // Parsing del CSV (salta l'header)
                let validLines = 0;
                let skippedLines = 0;
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const columns = line.split(';').map(col => col.trim().replace(/^["']|["']$/g, '')); // Rimuove virgolette iniziali/finali
                    
                    // Verifica che ci siano abbastanza colonne
                    // Id;R;Nome;Squadra;Pv;Mv;Fm;Gf;Gs;Rp;Rc;R+;R-;Ass;Amm;Esp;Au (17 colonne)
                    if (columns.length < 17) {
                        console.warn(`Riga ${i} ignorata: colonne insufficienti (${columns.length}/17)`, columns);
                        skippedLines++;
                        continue;
                    }
                    
                    const playerName = columns[2].trim(); // Nome √® ora la colonna 2 (era 3)
                    const normalizedName = playerName.toLowerCase();
                    const fantaSquad = playerToSquadMap.get(normalizedName) || 'SVINCOLATI';
                    
                    // Debug: log dei primi 5 giocatori
                    if (i <= 5) {
                        console.log(`Debug riga ${i}: playerName="${playerName}", normalized="${normalizedName}", fantaSquad="${fantaSquad}"`);
                    }
                    
                    const statData = {
                        playerId: columns[0],
                        role: columns[1], // P, D, C, A
                        playerName: playerName,
                        serieATeam: columns[3], // Squadra di Serie A
                        fantaSquad: fantaSquad, // Rosa fantacalcio (LIBERTAS, ORECCHIETTE, ecc.)
                        pv: parseFloat(columns[4]) || 0, // Partite a voto
                        mv: parseFloat(columns[5]) || 0, // Media voto
                        fm: parseFloat(columns[6]) || 0, // Fantamedia
                        gf: parseInt(columns[7]) || 0, // Gol fatti
                        gs: parseInt(columns[8]) || 0, // Gol subiti
                        rp: parseInt(columns[9]) || 0, // Rigori parati
                        rc: parseInt(columns[10]) || 0, // Rigori concessi
                        rPlus: parseInt(columns[11]) || 0, // Rigori segnati
                        rMinus: parseInt(columns[12]) || 0, // Rigori sbagliati
                        ass: parseInt(columns[13]) || 0, // Assist
                        amm: parseInt(columns[14]) || 0, // Ammonizioni
                        esp: parseInt(columns[15]) || 0, // Espulsioni
                        au: parseInt(columns[16]) || 0, // Autogol
                        lastUpdate: new Date().toISOString()
                    };
                    
                    stats.push(statData);
                    validLines++;
                    
                    // Progress update ogni 50 righe
                    if (validLines % 50 === 0) {
                        const progress = Math.floor((validLines / (lines.length - 1)) * 50);
                        updateProgress(progress, `Parsing: ${validLines} calciatori...`, null, null, 'stats-progress');
                    }
                }
                
                console.log(`Parsing completato: ${validLines} statistiche valide, ${skippedLines} righe ignorate`);
                updateProgress(50, `Cancellazione statistiche precedenti...`, null, null, 'stats-progress');
                
                // Cancella tutte le statistiche esistenti
                const existingStatsSnapshot = await getDocs(statsCollection);
                const deletePromises = existingStatsSnapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);
                
                console.log(`${deletePromises.length} statistiche precedenti cancellate`);
                updateProgress(60, `Salvataggio nuove statistiche...`, null, null, 'stats-progress');
                
                // Salva le nuove statistiche
                for (let i = 0; i < stats.length; i++) {
                    await addDoc(statsCollection, stats[i]);
                    
                    // Progress update ogni 20 salvataggi
                    if (i % 20 === 0 || i === stats.length - 1) {
                        const progress = 60 + Math.floor((i / stats.length) * 40);
                        updateProgress(progress, `Salvate ${i + 1}/${stats.length} statistiche...`, null, null, 'stats-progress');
                    }
                }
                
                updateProgress(100, 'Completato!', null, null, 'stats-progress');
                messageBox(`Statistiche caricate con successo! ${validLines} calciatori aggiornati.`);
                
                // Mostra riepilogo
                renderStatsSummary(stats);
                
                // Aggiorna leaderboards in home se disponibili
                if (typeof loadPlayerLeaderboards === 'function') {
                    loadPlayerLeaderboards();
                }
                
                // Reset UI
                setTimeout(() => {
                    uploadButton.disabled = false;
                    uploadButton.textContent = 'Carica Statistiche';
                    hideProgress('stats-progress');
                }, 2000);
                
            } catch (error) {
                console.error('Errore durante il caricamento delle statistiche:', error);
                messageBox('Errore durante il caricamento: ' + error.message);
                uploadButton.disabled = false;
                uploadButton.textContent = 'Carica Statistiche';
                hideProgress('stats-progress');
            }
        };
        
        const renderStatsSummary = (stats) => {
            const container = document.getElementById('stats-summary-container');
            if (!container) return;
            
            // Raggruppa per rosa fantacalcio
            const squadStats = new Map();
            stats.forEach(stat => {
                if (!squadStats.has(stat.fantaSquad)) {
                    squadStats.set(stat.fantaSquad, []);
                }
                squadStats.get(stat.fantaSquad).push(stat);
            });
            
            let html = '<div class="bg-gray-800 border border-blue-700/50 rounded-lg p-4 mb-4">';
            html += '<h5 class="text-lg font-bold text-blue-400 mb-3">Riepilogo Statistiche Caricate</h5>';
            html += '<div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-3">';
            
            // Ordina le squadre alfabeticamente
            const sortedSquads = Array.from(squadStats.entries()).sort((a, b) => a[0].localeCompare(b[0]));
            
            for (const [squadName, players] of sortedSquads) {
                const totalPv = players.reduce((sum, p) => sum + p.pv, 0);
                const avgFm = players.length > 0 ? (players.reduce((sum, p) => sum + p.fm, 0) / players.length).toFixed(2) : '0.00';
                
                html += `
                    <div class="bg-gray-700 rounded p-3 text-center">
                        <p class="text-sm font-bold text-white">${squadName}</p>
                        <p class="text-xs text-gray-400 mt-1">${players.length} giocatori</p>
                        <p class="text-xs text-blue-300">PV tot: ${totalPv}</p>
                        <p class="text-xs text-green-300">FM media: ${avgFm}</p>
                    </div>
                `;
            }
            
            html += '</div></div>';
            container.innerHTML = html;
        };
        
        // === FINE FUNZIONI STATISTICHE ADMIN ===
        
        // === FUNZIONI PER LA VISUALIZZAZIONE PUBBLICA DELLE STATISTICHE ===
        
        window.loadPlayerStats = async () => {
            try {
                const statsCollection = getPlayerStatsCollectionRef();
                const snapshot = await getDocs(statsCollection);
                
                if (snapshot.empty) {
                    document.getElementById('player-stats-view-container').innerHTML = '<p class="text-center text-gray-500 py-8">Nessuna statistica caricata. Contatta l\'admin per il caricamento.</p>';
                    return;
                }
                
                // Carica tutte le statistiche (escludi svincolati)
                const allStats = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // Escludi giocatori svincolati
                    if (data.fantaSquad && data.fantaSquad !== 'SVINCOLATI') {
                        allStats.push(data);
                    }
                });
                
                // Popola i filtri
                const squadFilter = document.getElementById('stats-squad-filter');
                const uniqueSquads = [...new Set(allStats.map(s => s.fantaSquad))].sort();
                squadFilter.innerHTML = '<option value="all">Tutte le rose</option>';
                uniqueSquads.forEach(squad => {
                    squadFilter.innerHTML += `<option value="${squad}">${squad}</option>`;
                });
                
                // Salva globalmente per i filtri
                window.currentPlayerStats = allStats;
                window.currentFilteredStats = allStats;
                
                // Mostra tutte le statistiche con ordinamento default
                sortPlayerStats(currentSortColumn);
                
            } catch (error) {
                console.error('Errore nel caricamento delle statistiche:', error);
                messageBox('Errore nel caricamento delle statistiche.');
            }
        };
        
        // Variabili per l'ordinamento
        let currentSortColumn = 'fm';
        let currentSortDirection = 'desc';
        
        const renderPlayerStatsView = (stats) => {
            const container = document.getElementById('player-stats-view-container');
            if (!container) return;
            
            if (stats.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-500 py-8">Nessun giocatore trovato con i filtri selezionati.</p>';
                return;
            }
            
            const getSortIcon = (column) => {
                if (currentSortColumn !== column) {
                    return '<svg class="w-3 h-3 inline ml-1 text-gray-500" fill="currentColor" viewBox="0 0 20 20"><path d="M5 12a1 1 0 102 0V6.414l1.293 1.293a1 1 0 001.414-1.414l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L5 6.414V12zM15 8a1 1 0 10-2 0v5.586l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L15 13.586V8z"></path></svg>';
                }
                if (currentSortDirection === 'asc') {
                    return '<svg class="w-3 h-3 inline ml-1 text-blue-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 9.707a1 1 0 010-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 01-1.414 1.414L11 7.414V15a1 1 0 11-2 0V7.414L6.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>';
                } else {
                    return '<svg class="w-3 h-3 inline ml-1 text-blue-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M14.707 10.293a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 111.414-1.414L9 12.586V5a1 1 0 012 0v7.586l2.293-2.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>';
                }
            };
            
            let html = '<div class="overflow-x-auto">';
            html += '<table class="min-w-full bg-gray-800 rounded-lg overflow-hidden text-sm">';
            html += `
                <thead>
                    <tr class="bg-gray-700 text-gray-300 text-xs uppercase">
                        <th onclick="sortPlayerStats('playerName')" class="px-3 py-2 text-left sticky left-0 bg-gray-700 z-10 cursor-pointer hover:bg-gray-600 transition-colors">
                            Calciatore ${getSortIcon('playerName')}
                        </th>
                        <th onclick="sortPlayerStats('fantaSquad')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            Rosa ${getSortIcon('fantaSquad')}
                        </th>
                        <th onclick="sortPlayerStats('role')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            Ruolo ${getSortIcon('role')}
                        </th>
                        <th onclick="sortPlayerStats('serieATeam')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            Squadra ${getSortIcon('serieATeam')}
                        </th>
                        <th onclick="sortPlayerStats('pv')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            PV ${getSortIcon('pv')}
                        </th>
                        <th onclick="sortPlayerStats('mv')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            MV ${getSortIcon('mv')}
                        </th>
                        <th onclick="sortPlayerStats('fm')" class="px-3 py-2 text-center bg-blue-900/30 cursor-pointer hover:bg-blue-800/40 transition-colors">
                            FM ${getSortIcon('fm')}
                        </th>
                        <th onclick="sortPlayerStats('gf')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            GF ${getSortIcon('gf')}
                        </th>
                        <th onclick="sortPlayerStats('gs')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            GS ${getSortIcon('gs')}
                        </th>
                        <th onclick="sortPlayerStats('rp')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            RP ${getSortIcon('rp')}
                        </th>
                        <th onclick="sortPlayerStats('rc')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            RC ${getSortIcon('rc')}
                        </th>
                        <th onclick="sortPlayerStats('rPlus')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            R+ ${getSortIcon('rPlus')}
                        </th>
                        <th onclick="sortPlayerStats('rMinus')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            R- ${getSortIcon('rMinus')}
                        </th>
                        <th onclick="sortPlayerStats('ass')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            ASS ${getSortIcon('ass')}
                        </th>
                        <th onclick="sortPlayerStats('amm')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            AMM ${getSortIcon('amm')}
                        </th>
                        <th onclick="sortPlayerStats('esp')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            ESP ${getSortIcon('esp')}
                        </th>
                        <th onclick="sortPlayerStats('au')" class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors">
                            AU ${getSortIcon('au')}
                        </th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            const roleColors = {
                'P': 'text-yellow-400',
                'D': 'text-blue-400',
                'C': 'text-green-400',
                'A': 'text-red-400'
            };
            
            stats.forEach((stat, index) => {
                const bgClass = index % 2 === 0 ? 'bg-gray-800' : 'bg-gray-750';
                const roleColor = roleColors[stat.role] || 'text-white';
                
                html += `
                    <tr class="${bgClass} hover:bg-gray-700 transition-colors">
                        <td class="px-3 py-2 font-medium sticky left-0 ${bgClass} z-10">${stat.playerName}</td>
                        <td class="px-3 py-2 text-center text-xs text-purple-400">${stat.fantaSquad}</td>
                        <td class="px-3 py-2 text-center font-bold ${roleColor}">${stat.role}</td>
                        <td class="px-3 py-2 text-center text-xs text-gray-400">${stat.serieATeam}</td>
                        <td class="px-3 py-2 text-center">${stat.pv}</td>
                        <td class="px-3 py-2 text-center">${stat.mv.toFixed(2)}</td>
                        <td class="px-3 py-2 text-center font-bold text-blue-300 bg-blue-900/20">${stat.fm.toFixed(2)}</td>
                        <td class="px-3 py-2 text-center ${stat.gf > 0 ? 'text-green-400 font-bold' : ''}">${stat.gf || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.gs > 0 ? 'text-red-400' : ''}">${stat.gs || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.rp > 0 ? 'text-green-400' : ''}">${stat.rp || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.rc > 0 ? 'text-red-400' : ''}">${stat.rc || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.rPlus > 0 ? 'text-green-400' : ''}">${stat.rPlus || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.rMinus > 0 ? 'text-red-400' : ''}">${stat.rMinus || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.ass > 0 ? 'text-blue-400 font-bold' : ''}">${stat.ass || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.amm > 0 ? 'text-yellow-400' : ''}">${stat.amm || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.esp > 0 ? 'text-red-500 font-bold' : ''}">${stat.esp || '-'}</td>
                        <td class="px-3 py-2 text-center ${stat.au > 0 ? 'text-red-400' : ''}">${stat.au || '-'}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        };
        
        window.sortPlayerStats = (column) => {
            if (!window.currentFilteredStats) return;
            
            // Se clicco sulla stessa colonna, inverto la direzione
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // Nuova colonna: default decrescente per numeri, crescente per testo
                currentSortColumn = column;
                const textColumns = ['playerName', 'fantaSquad', 'role', 'serieATeam'];
                currentSortDirection = textColumns.includes(column) ? 'asc' : 'desc';
            }
            
            // Ordina i dati
            const sorted = [...window.currentFilteredStats].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];
                
                // Gestione valori nulli/undefined
                if (valA === null || valA === undefined) valA = 0;
                if (valB === null || valB === undefined) valB = 0;
                
                // Confronto
                if (typeof valA === 'string' && typeof valB === 'string') {
                    return currentSortDirection === 'asc' 
                        ? valA.localeCompare(valB) 
                        : valB.localeCompare(valA);
                } else {
                    return currentSortDirection === 'asc' 
                        ? valA - valB 
                        : valB - valA;
                }
            });
            
            window.currentFilteredStats = sorted;
            renderPlayerStatsView(sorted);
        };
        
        window.filterPlayerStats = () => {
            if (!window.currentPlayerStats) return;
            
            const squadFilter = document.getElementById('stats-squad-filter').value;
            const roleFilter = document.getElementById('stats-role-filter').value;
            
            let filtered = [...window.currentPlayerStats];
            
            // Applica filtri
            if (squadFilter !== 'all') {
                filtered = filtered.filter(s => s.fantaSquad === squadFilter);
            }
            
            if (roleFilter !== 'all') {
                filtered = filtered.filter(s => s.role === roleFilter);
            }
            
            // Salva i dati filtrati e applica l'ordinamento corrente
            window.currentFilteredStats = filtered;
            sortPlayerStats(currentSortColumn);
        };
        
        // === FUNZIONI STATISTICHE CALCIATORI HOME PAGE ===
        
        window.loadPlayerLeaderboards = async () => {
            try {
                const playerStatsRef = getPlayerStatsCollectionRef();
                const snapshot = await getDocs(playerStatsRef);
                
                if (snapshot.empty) {
                    document.getElementById('player-statistics-container').innerHTML = 
                        '<p class="text-sm sm:text-base text-gray-500 text-center py-4 col-span-full">Nessuna statistica disponibile</p>';
                    return;
                }
                
                const allStats = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // Escludi giocatori svincolati (senza squadra)
                    if (data.fantaSquad && data.fantaSquad !== 'SVINCOLATI') {
                        allStats.push({
                            ...data,
                            gf: Number(data.gf) || 0,
                            ass: Number(data.ass) || 0,
                            gs: Number(data.gs) || 0,
                            fm: Number(data.fm) || 0,
                            pv: Number(data.pv) || 0
                        });
                    }
                });
                
                // Calcola il numero totale di giornate di Serie A giocate
                // Fantacalcio giornata 1 = Serie A giornata 3
                // Quindi: Serie A giornata = Fantacalcio giornata + 2
                const lastFantaGiornata = allResults.length > 0 
                    ? Math.max(...allResults.map(r => parseInt(r.giornata) || 0))
                    : 0;
                const totalGiornate = lastFantaGiornata + 2; // Converti giornata fanta in giornata Serie A
                
                console.log('Ultima giornata Fanta:', lastFantaGiornata, '‚Üí Giornate Serie A:', totalGiornate); // Debug
                
                // Top 3 Marcatori (gol segnati)
                const topScorers = allStats
                    .filter(p => p.gf > 0)
                    .sort((a, b) => b.gf - a.gf)
                    .slice(0, 3);
                
                // Top 3 Assistman
                const topAssistmen = allStats
                    .filter(p => p.ass > 0)
                    .sort((a, b) => b.ass - a.ass)
                    .slice(0, 3);
                
                // Top 3 Portieri (meno gol subiti, min 3 presenze)
                const topGoalkeepers = allStats
                    .filter(p => p.role === 'P' && p.pv >= 3)
                    .sort((a, b) => a.gs - b.gs)
                    .slice(0, 3);
                
                // Top 3 FantaMedia (min 3 presenze)
                const topFantaMedia = allStats
                    .filter(p => p.pv >= 3 && p.fm > 0)
                    .sort((a, b) => b.fm - a.fm)
                    .slice(0, 3);
                
                renderPlayerLeaderboards({
                    scorers: topScorers,
                    assistmen: topAssistmen,
                    goalkeepers: topGoalkeepers,
                    fantaMedia: topFantaMedia
                }, totalGiornate);
                
            } catch (error) {
                console.error('Errore caricamento statistiche calciatori:', error);
                document.getElementById('player-statistics-container').innerHTML = 
                    '<p class="text-sm sm:text-base text-red-500 text-center py-4 col-span-full">Errore nel caricamento delle statistiche</p>';
            }
        };
        
        const renderPlayerLeaderboards = (data, totalGiornate = 0) => {
            const container = document.getElementById('player-statistics-container');
            
            const getRoleColor = (role) => {
                const colors = {
                    'P': 'text-yellow-300',
                    'D': 'text-blue-300',
                    'C': 'text-green-300',
                    'A': 'text-red-300'
                };
                return colors[role] || 'text-gray-300';
            };
            
            const getRoleBadge = (role) => {
                const badges = {
                    'P': 'bg-yellow-500/20 text-yellow-300 border-yellow-500/30',
                    'D': 'bg-blue-500/20 text-blue-300 border-blue-500/30',
                    'C': 'bg-green-500/20 text-green-300 border-green-500/30',
                    'A': 'bg-red-500/20 text-red-300 border-red-500/30'
                };
                return badges[role] || 'bg-gray-500/20 text-gray-300 border-gray-500/30';
            };
            
            const renderLeaderboard = (title, players, statKey, statLabel, icon, cardColor, iconColor, statColor) => {
                if (players.length === 0) {
                    return `
                        <div class="bg-gradient-to-br ${cardColor} border ${iconColor.replace('text-', 'border-')}/50 rounded-lg p-4">
                            <div class="flex items-center mb-3">
                                ${icon}
                                <h4 class="text-sm font-bold ${iconColor} uppercase ml-2">${title}</h4>
                            </div>
                            <p class="text-gray-400 text-sm">Nessun dato disponibile</p>
                        </div>
                    `;
                }
                
                const playersList = players.map((p, idx) => {
                    const logoUrl = getTeamLogo(p.fantaSquad);
                    const isFirst = idx === 0;
                    const presenze = p.pv || 0;
                    const presenzeText = `${presenze}/${totalGiornate}`;
                    
                    return `
                        <div class="flex items-center justify-between ${isFirst ? 'py-3 mb-2 border-b-2' : 'py-2.5'} ${idx < players.length - 1 && !isFirst ? 'border-b border-gray-700/30' : ''} ${isFirst ? 'border-' + iconColor.replace('text-', '') + '/50' : ''}">
                            <div class="flex items-center gap-2 flex-1 min-w-0">
                                <div class="flex items-center gap-2 flex-1 min-w-0">
                                    ${logoUrl ? `<img src="${logoUrl}" alt="${p.fantaSquad}" class="${isFirst ? 'w-10 h-10' : 'w-7 h-7'} object-contain flex-shrink-0" onerror="this.style.display='none'">` : ''}
                                    <div class="flex-1 min-w-0">
                                        <p class="${isFirst ? 'text-base sm:text-lg' : 'text-sm'} font-bold text-white truncate">${p.playerName || 'N/A'}</p>
                                        <div class="flex items-center gap-1.5 mt-0.5 flex-wrap">
                                            <span class="${isFirst ? 'text-xs' : 'text-xs'} px-2 py-0.5 rounded border ${getRoleBadge(p.role)} font-bold">${p.role}</span>
                                            <span class="${isFirst ? 'text-sm' : 'text-xs'} ${isFirst ? iconColor : 'text-gray-400'} font-semibold truncate">${p.fantaSquad || 'N/A'}</span>
                                            <span class="text-xs text-gray-500">‚Ä¢ ${presenzeText}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-right ml-3 flex-shrink-0">
                                <p class="${isFirst ? 'text-3xl sm:text-4xl' : 'text-2xl'} font-bold ${statColor}">${statKey === 'fm' ? Number(p[statKey]).toFixed(1) : p[statKey]}</p>
                                <p class="text-xs text-gray-400 uppercase">${statLabel}</p>
                            </div>
                        </div>
                    `;
                }).join('');
                
                return `
                    <div class="bg-gradient-to-br ${cardColor} border ${iconColor.replace('text-', 'border-')}/50 rounded-lg p-4">
                        <div class="flex items-center mb-3">
                            ${icon}
                            <h4 class="text-sm font-bold ${iconColor} uppercase ml-2">${title}</h4>
                        </div>
                        <div class="space-y-0">
                            ${playersList}
                        </div>
                    </div>
                `;
            };
            
            const scorersIcon = '<svg class="w-5 h-5 text-red-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M12.395 2.553a1 1 0 00-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31.365 31.365 0 00-.613 3.58 2.64 2.64 0 01-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 005.05 6.05 6.981 6.981 0 003 11a7 7 0 1011.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03zM12.12 15.12A3 3 0 017 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A2.99 2.99 0 0113 13a2.99 2.99 0 01-.879 2.121z" clip-rule="evenodd"></path></svg>';
            
            const assistIcon = '<svg class="w-5 h-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"></path></svg>';
            
            const gkIcon = '<svg class="w-5 h-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>';
            
            const fmIcon = '<svg class="w-5 h-5 text-purple-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg>';
            
            container.innerHTML = `
                ${renderLeaderboard('Top Marcatori', data.scorers, 'gf', 'gol', scorersIcon, 'from-red-900/30 to-red-800/20', 'text-red-400', 'text-red-400')}
                ${renderLeaderboard('Top Assist', data.assistmen, 'ass', 'assist', assistIcon, 'from-blue-900/30 to-blue-800/20', 'text-blue-400', 'text-blue-400')}
                ${renderLeaderboard('Migliori Portieri', data.goalkeepers, 'gs', 'gol sub.', gkIcon, 'from-yellow-900/30 to-yellow-800/20', 'text-yellow-400', 'text-yellow-400')}
                ${renderLeaderboard('Miglior FantaMedia', data.fantaMedia, 'fm', 'FM', fmIcon, 'from-purple-900/30 to-purple-800/20', 'text-purple-400', 'text-purple-400')}
            `;
        };
        
        // === FINE FUNZIONI STATISTICHE PUBBLICHE ===

        // Funzione di supporto: ricalibra quote pure per ottenere un margine target
const adjustOddsForMargin = (q1, qX, q2, targetMargin = 0.05) => {
    // Protezione contro divisioni per zero
    const eps = 1e-6;
    q1 = Math.max(q1, eps);
    qX = Math.max(qX, eps);
    q2 = Math.max(q2, eps);

    // Log per debug delle quote in ingresso
    try {
        console.log('adjustOddsForMargin input:', { q1, qX, q2, targetMargin });
    } catch (e) { /* no-op */ }

                // Step 1: probabilit√† "pure"
                let p1 = 1 / q1;
                let pX = 1 / qX;
                let p2 = 1 / q2;
                const totalPure = p1 + pX + p2;

                // Step 2: target sum = 1 + margine
                const targetSum = 1 + targetMargin;    // Step 3: scala le probabilit√† in modo che la loro somma = targetSum
    const scale = targetSum / totalPure;
    const p1Adj = p1 * scale;
    const pXAdj = pX * scale;
    const p2Adj = p2 * scale;

    // Step 4: nuove quote
    const q1New = 1 / p1Adj;
    const qXNew = 1 / pXAdj;
    const q2New = 1 / p2Adj;

    // Step 5: overround effettivo (verifica)
    const overround = (p1Adj + pXAdj + p2Adj) - 1;

    return {
        '1': parseFloat(q1New.toFixed(2)),
        'X': parseFloat(qXNew.toFixed(2)),
        '2': parseFloat(q2New.toFixed(2)),
        overround: parseFloat(overround.toFixed(4))
    };
};

// Funzione per il calcolo delle quote (Revisione) ‚Äî usa adjustOddsForMargin
const calculateOdds = (homeTeam, awayTeam) => {
    // 1. Conteggio scontri diretti
    const matchesAgainst = allResults.filter(r =>
        (r.homeTeam === homeTeam && r.awayTeam === awayTeam) ||
        (r.homeTeam === awayTeam && r.awayTeam === homeTeam)
    );

    let homeTeamWins = 0;
    let awayTeamWins = 0;
    let draws = 0;

    matchesAgainst.forEach(r => {
        if (r.homeTeam === homeTeam && r.awayTeam === awayTeam) {
            if (r.result === '1') homeTeamWins++;
            else if (r.result === 'X') draws++;
            else if (r.result === '2') awayTeamWins++;
        } else if (r.homeTeam === awayTeam && r.awayTeam === homeTeam) {
            if (r.result === '1') awayTeamWins++;
            else if (r.result === 'X') draws++;
            else if (r.result === '2') homeTeamWins++;
        }
    });

    const totalEncounters = homeTeamWins + awayTeamWins + draws;

    // 2. Calcola statistiche generali delle squadre
    const homeStats = calculateTeamStats(homeTeam);
    const awayStats = calculateTeamStats(awayTeam);

    // 3. Calcola fattore di forza basato sulla classifica
    const maxPoints = Math.max(homeStats.points, awayStats.points, 1);
    const homeStrength = homeStats.matchesPlayed > 0 ? homeStats.points / (homeStats.matchesPlayed * 3) : 0.5;
    const awayStrength = awayStats.matchesPlayed > 0 ? awayStats.points / (awayStats.matchesPlayed * 3) : 0.5;
    
    // Fattore casa: bonus del 10% per la squadra di casa
    const homeBonus = 0.10;

    // 4. Combina scontri diretti con statistiche generali
    let p1, pX, p2;
    
    if (totalEncounters === 0) {
        // Nessun scontro diretto: usa statistiche generali + classifica
        const homeAdjusted = homeStrength + homeBonus;
        const awayAdjusted = awayStrength;
        
        p1 = homeStats.homeWinRate * 0.5 + homeAdjusted * 0.5;
        p2 = awayStats.awayWinRate * 0.5 + awayAdjusted * 0.5;
        pX = Math.max(0.20, Math.min(0.35, (homeStats.drawRate + awayStats.drawRate) / 2)); // Pareggio tra 20% e 35%
    } else {
        // Combina scontri diretti (50%) con statistiche generali (30%) e classifica (20%)
        const directP1 = homeTeamWins / totalEncounters;
        const directP2 = awayTeamWins / totalEncounters;
        const directPX = draws / totalEncounters;
        
        const homeAdjusted = homeStrength + homeBonus;
        const awayAdjusted = awayStrength;
        
        const generalP1 = homeStats.homeWinRate * 0.6 + homeAdjusted * 0.4;
        const generalP2 = awayStats.awayWinRate * 0.6 + awayAdjusted * 0.4;
        const generalPX = (homeStats.drawRate + awayStats.drawRate) / 2;
        
        p1 = directP1 * 0.5 + generalP1 * 0.5;
        p2 = directP2 * 0.5 + generalP2 * 0.5;
        pX = directPX * 0.5 + generalPX * 0.5;
        
        // Assicura che il pareggio non sia troppo basso o troppo alto
        pX = Math.max(0.15, Math.min(0.40, pX)); // Pareggio tra 15% e 40%
    }

    // Normalizza le probabilit√†
    const sum = p1 + pX + p2 || 1;
    p1 /= sum; 
    pX /= sum; 
    p2 /= sum;

    // Converti probabilit√† in quote pure con limiti
    const q1Pure = Math.min(15, Math.max(1.20, 1 / Math.max(p1, 0.08))); // Quote tra 1.20 e 15.00
    const qXPure = Math.min(8, Math.max(2.50, 1 / Math.max(pX, 0.15))); // Quote X tra 2.50 e 8.00
    const q2Pure = Math.min(20, Math.max(1.20, 1 / Math.max(p2, 0.06))); // Quote tra 1.20 e 20.00

    // Applica il margine del bookmaker
    const TARGET_MARGIN = 0.08; // 8% di margine
    const adjusted = adjustOddsForMargin(q1Pure, qXPure, q2Pure, TARGET_MARGIN);

    return {
        '1': adjusted['1'].toFixed(2),
        'X': adjusted['X'].toFixed(2),
        '2': adjusted['2'].toFixed(2),
        overround: adjusted.overround
    };
};

// Funzione helper per calcolare le statistiche di una squadra
const calculateTeamStats = (teamName) => {
    const homeMatches = allResults.filter(r => r.homeTeam === teamName);
    const awayMatches = allResults.filter(r => r.awayTeam === teamName);
    const allMatches = [...homeMatches, ...awayMatches];

    if (allMatches.length === 0) {
        return {
            homeWinRate: 0.35,
            awayWinRate: 0.25,
            overallWinRate: 0.30,
            drawRate: 0.30,
            points: 0,
            matchesPlayed: 0,
            wins: 0,
            draws: 0,
            losses: 0,
            goalsFor: 0,
            goalsAgainst: 0,
            goalDifference: 0
        };
    }

    // Statistiche in casa
    let homeWins = homeMatches.filter(r => r.result === '1').length;
    let homeDraws = homeMatches.filter(r => r.result === 'X').length;
    let homeLosses = homeMatches.filter(r => r.result === '2').length;
    
    // Statistiche in trasferta
    let awayWins = awayMatches.filter(r => r.result === '2').length;
    let awayDraws = awayMatches.filter(r => r.result === 'X').length;
    let awayLosses = awayMatches.filter(r => r.result === '1').length;
    
    // Statistiche totali
    let totalWins = homeWins + awayWins;
    let totalDraws = homeDraws + awayDraws;
    let totalPoints = (totalWins * 3) + totalDraws; // Punti in classifica

    // Calcola gol fatti e subiti
    let goalsFor = 0;
    let goalsAgainst = 0;
    let totalFantasyPoints = 0; // Somma punteggi fantacalcio
    
    // Gol in casa (squadra √® homeTeam)
    homeMatches.forEach(r => {
        if (r.score && r.score.includes('-')) {
            const [home, away] = r.score.split('-').map(g => parseInt(g.trim(), 10));
            if (!isNaN(home) && !isNaN(away)) {
                goalsFor += home;
                goalsAgainst += away;
            }
        }
        // Aggiungi punteggio fantacalcio in casa
        if (r.homePoints) {
            totalFantasyPoints += r.homePoints;
        }
    });
    
    // Gol in trasferta (squadra √® awayTeam)
    awayMatches.forEach(r => {
        if (r.score && r.score.includes('-')) {
            const [home, away] = r.score.split('-').map(g => parseInt(g.trim(), 10));
            if (!isNaN(home) && !isNaN(away)) {
                goalsFor += away;
                goalsAgainst += home;
            }
        }
        // Aggiungi punteggio fantacalcio in trasferta
        if (r.awayPoints) {
            totalFantasyPoints += r.awayPoints;
        }
    });
    
    const goalDifference = goalsFor - goalsAgainst;

    return {
        homeWinRate: homeMatches.length > 0 ? homeWins / homeMatches.length : 0.35,
        awayWinRate: awayMatches.length > 0 ? awayWins / awayMatches.length : 0.25,
        overallWinRate: allMatches.length > 0 ? totalWins / allMatches.length : 0.30,
        drawRate: allMatches.length > 0 ? totalDraws / allMatches.length : 0.25,
        points: totalPoints,
        matchesPlayed: allMatches.length,
        wins: totalWins,
        draws: totalDraws,
        losses: homeLosses + awayLosses,
        goalsFor: goalsFor,
        goalsAgainst: goalsAgainst,
        goalDifference: goalDifference,
        fantasyPoints: totalFantasyPoints  // Nuovo campo
    };
};

// Funzione per calcolare la classifica completa
const calculateStandings = () => {
    const standings = [];
    const teamsSet = new Set();
    
    // Raccogli tutte le squadre uniche
    allResults.forEach(r => {
        teamsSet.add(r.homeTeam);
        teamsSet.add(r.awayTeam);
    });
    
    // Calcola statistiche per ogni squadra
    teamsSet.forEach(teamName => {
        const stats = calculateTeamStats(teamName);
        standings.push({
            team: teamName,
            points: stats.points,
            played: stats.matchesPlayed,
            wins: stats.wins,
            draws: stats.draws,
            losses: stats.losses,
            goalsFor: stats.goalsFor,
            goalsAgainst: stats.goalsAgainst,
            goalDifference: stats.goalDifference,
            fantasyPoints: stats.fantasyPoints  // Aggiungi punteggi fantacalcio
        });
    });
    
    // Ordina per: 1. Punti, 2. Somma punti totale (fantasy), 3. Differenza reti, 4. Gol fatti, 5. Gol subiti, 6. Classifica avulsa (da implementare)
    standings.sort((a, b) => {
        // 1. Punti in classifica (decrescente)
        if (b.points !== a.points) return b.points - a.points;
        
        // 2. Somma punti totale fantacalcio (decrescente)
        if (b.fantasyPoints !== a.fantasyPoints) return b.fantasyPoints - a.fantasyPoints;
        
        // 3. Differenza reti (decrescente)
        if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
        
        // 4. Gol fatti (decrescente)
        if (b.goalsFor !== a.goalsFor) return b.goalsFor - a.goalsFor;
        
        // 5. Gol subiti (crescente - meno gol subiti √® meglio)
        if (a.goalsAgainst !== b.goalsAgainst) return a.goalsAgainst - b.goalsAgainst;
        
        // 6. Classifica avulsa (da implementare - per ora parit√†)
        return 0;
    });
    
    return standings;
};

// Funzione per renderizzare la classifica nella homepage
window.renderStandings = (sortColumn = null) => {
    const container = document.getElementById('standings-container');
    if (!container) return;
    
    let standings = calculateStandings();
    
    if (standings.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-center py-4">Nessun dato disponibile</p>';
        return;
    }
    
    // Gestisci l'ordinamento personalizzato
    if (sortColumn) {
        // Se clicchi sulla stessa colonna, inverti la direzione
        if (standingsSortColumn === sortColumn) {
            standingsSortDirection = standingsSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            standingsSortColumn = sortColumn;
            standingsSortDirection = sortColumn === 'team' ? 'asc' : 'desc'; // Default desc per numeri, asc per nomi
        }
        
        // Ordina in base alla colonna selezionata
        standings.sort((a, b) => {
            let valA, valB;
            
            switch(sortColumn) {
                case 'team':
                    valA = a.team.toLowerCase();
                    valB = b.team.toLowerCase();
                    break;
                case 'points':
                    valA = a.points;
                    valB = b.points;
                    break;
                case 'fantasyPoints':
                    valA = a.fantasyPoints || 0;
                    valB = b.fantasyPoints || 0;
                    break;
                case 'played':
                    valA = a.played;
                    valB = b.played;
                    break;
                case 'wins':
                    valA = a.wins;
                    valB = b.wins;
                    break;
                case 'draws':
                    valA = a.draws;
                    valB = b.draws;
                    break;
                case 'losses':
                    valA = a.losses;
                    valB = b.losses;
                    break;
                case 'goalsFor':
                    valA = a.goalsFor;
                    valB = b.goalsFor;
                    break;
                case 'goalsAgainst':
                    valA = a.goalsAgainst;
                    valB = b.goalsAgainst;
                    break;
                case 'goalDifference':
                    valA = a.goalDifference;
                    valB = b.goalDifference;
                    break;
                default:
                    return 0;
            }
            
            if (standingsSortDirection === 'asc') {
                return valA < valB ? -1 : valA > valB ? 1 : 0;
            } else {
                return valA > valB ? -1 : valA < valB ? 1 : 0;
            }
        });
    } else {
        // Reset ordinamento personalizzato se non viene specificata una colonna
        standingsSortColumn = null;
    }
    
    // Funzione per generare l'icona di ordinamento
    const getSortIcon = (column) => {
        if (standingsSortColumn !== column) {
            return '<svg class="w-3 h-3 inline-block ml-1 opacity-30" fill="currentColor" viewBox="0 0 20 20"><path d="M5 12a1 1 0 102 0V6.414l1.293 1.293a1 1 0 001.414-1.414l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L5 6.414V12zM15 8a1 1 0 10-2 0v5.586l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L15 13.586V8z"></path></svg>';
        }
        if (standingsSortDirection === 'asc') {
            return '<svg class="w-3 h-3 inline-block ml-1" fill="currentColor" viewBox="0 0 20 20"><path d="M3 3a1 1 0 000 2h11a1 1 0 100-2H3zM3 7a1 1 0 000 2h7a1 1 0 100-2H3zM3 11a1 1 0 100 2h4a1 1 0 100-2H3zM15 8a1 1 0 10-2 0v5.586l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L15 13.586V8z"></path></svg>';
        } else {
            return '<svg class="w-3 h-3 inline-block ml-1" fill="currentColor" viewBox="0 0 20 20"><path d="M3 3a1 1 0 000 2h11a1 1 0 100-2H3zM3 7a1 1 0 000 2h5a1 1 0 000-2H3zM3 11a1 1 0 100 2h4a1 1 0 100-2H3zM13 16a1 1 0 102 0v-5.586l1.293 1.293a1 1 0 001.414-1.414l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 101.414 1.414L13 10.414V16z"></path></svg>';
        }
    };
    
    const table = document.createElement('table');
    table.className = 'min-w-full bg-gray-800 rounded-lg overflow-hidden';
    
    table.innerHTML = `
        <thead>
            <tr class="bg-gray-700 text-gray-400 text-sm">
                <th class="px-3 py-2 text-center">#</th>
                <th class="px-4 py-2 text-left cursor-pointer hover:bg-gray-600 transition-colors" colspan="2" onclick="renderStandings('team')">
                    Squadra ${getSortIcon('team')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('points')">
                    Pt ${getSortIcon('points')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('fantasyPoints')">
                    Pti ${getSortIcon('fantasyPoints')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('played')">
                    G ${getSortIcon('played')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('wins')">
                    V ${getSortIcon('wins')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('draws')">
                    N ${getSortIcon('draws')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('losses')">
                    P ${getSortIcon('losses')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('goalsFor')">
                    GF ${getSortIcon('goalsFor')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('goalsAgainst')">
                    GS ${getSortIcon('goalsAgainst')}
                </th>
                <th class="px-3 py-2 text-center cursor-pointer hover:bg-gray-600 transition-colors" onclick="renderStandings('goalDifference')">
                    DR ${getSortIcon('goalDifference')}
                </th>
            </tr>
        </thead>
        <tbody class="text-gray-300">
            ${standings.map((team, index) => {
                const position = index + 1;
                const totalTeams = standings.length;
                const isLast = position === totalTeams;
                
                // Classe per la posizione
                let positionClass = '';
                if (position === 1) positionClass = 'text-yellow-300 font-bold text-lg';
                else if (position === 2) positionClass = 'text-gray-200 font-bold';
                else if (position === 3) positionClass = 'text-orange-300 font-bold';
                else if (isLast) positionClass = 'text-red-300 font-bold';
                
                // Classe per la riga - evidenzia le prime 3 e l'ultima con colori pi√π vivaci
                let rowClass = 'border-b border-gray-700 hover:bg-gray-750';
                if (position === 1) {
                    rowClass = 'border-b-2 border-l-4 border-l-yellow-400 border-b-yellow-400/50 bg-gradient-to-r from-yellow-500/25 to-yellow-500/5 hover:from-yellow-500/35 hover:to-yellow-500/10';
                } else if (position === 2) {
                    rowClass = 'border-b-2 border-l-4 border-l-slate-400 border-b-slate-400/50 bg-gradient-to-r from-slate-500/25 to-slate-500/5 hover:from-slate-500/35 hover:to-slate-500/10';
                } else if (position === 3) {
                    rowClass = 'border-b-2 border-l-4 border-l-orange-400 border-b-orange-400/50 bg-gradient-to-r from-orange-500/25 to-orange-500/5 hover:from-orange-500/35 hover:to-orange-500/10';
                } else if (isLast) {
                    rowClass = 'border-b-2 border-l-4 border-l-red-500 border-b-red-500/50 bg-gradient-to-r from-red-500/25 to-red-500/5 hover:from-red-500/35 hover:to-red-500/10';
                }
                
                // Colore per la differenza reti
                let drClass = 'text-gray-300';
                if (team.goalDifference > 0) drClass = 'text-green-400 font-semibold';
                else if (team.goalDifference < 0) drClass = 'text-red-400 font-semibold';
                
                return `
                    <tr class="${rowClass}">
                        <td class="px-3 py-3 text-center ${positionClass}">${position}</td>
                        <td class="px-2 py-3 text-center">
                            <img src="${getTeamLogo(team.team)}" alt="${team.team}" class="w-8 h-8 object-contain mx-auto" onerror="this.style.display='none'">
                        </td>
                        <td class="px-2 py-3 text-left font-semibold">${team.team}</td>
                        <td class="px-3 py-3 text-center font-bold text-green-400">${team.points}</td>
                        <td class="px-3 py-3 text-center font-bold text-blue-400">${team.fantasyPoints ? team.fantasyPoints.toFixed(1) : '0.0'}</td>
                        <td class="px-3 py-3 text-center text-sm">${team.played}</td>
                        <td class="px-3 py-3 text-center text-sm text-green-300">${team.wins}</td>
                        <td class="px-3 py-3 text-center text-sm text-yellow-300">${team.draws}</td>
                        <td class="px-3 py-3 text-center text-sm text-red-300">${team.losses}</td>
                        <td class="px-3 py-3 text-center text-sm">${team.goalsFor}</td>
                        <td class="px-3 py-3 text-center text-sm">${team.goalsAgainst}</td>
                        <td class="px-3 py-3 text-center text-sm font-semibold ${drClass}">${team.goalDifference > 0 ? '+' : ''}${team.goalDifference}</td>
                    </tr>
                `;
            }).join('')}
        </tbody>
    `;
    
    container.innerHTML = '';
    container.appendChild(table);
};

// Funzione per calcolare l'andamento della classifica giornata per giornata
const calculateStandingsTrend = () => {
    // Raggruppa i risultati per giornata
    const resultsByGiornata = new Map();
    allResults.forEach(r => {
        const giornataNum = parseInt(r.giornata) || 0;
        if (giornataNum > 0) {
            if (!resultsByGiornata.has(giornataNum)) {
                resultsByGiornata.set(giornataNum, []);
            }
            resultsByGiornata.get(giornataNum).push(r);
        }
    });
    
    if (resultsByGiornata.size === 0) return null;
    
    // Ordina le giornate
    const sortedGiornate = Array.from(resultsByGiornata.keys()).sort((a, b) => a - b);
    
    // Calcola la classifica progressiva per ogni giornata
    const teamTrends = new Map();
    const allTeamsSet = new Set();
    
    // Raccogli tutte le squadre
    allResults.forEach(r => {
        allTeamsSet.add(r.homeTeam);
        allTeamsSet.add(r.awayTeam);
    });
    
    // Inizializza le squadre
    allTeamsSet.forEach(team => {
        teamTrends.set(team, []);
    });
    
    // Per ogni giornata, calcola la classifica cumulativa
    let cumulativeResults = [];
    sortedGiornate.forEach(giornata => {
        const giornataResults = resultsByGiornata.get(giornata);
        cumulativeResults = [...cumulativeResults, ...giornataResults];
        
        // Calcola classifica fino a questa giornata
        const standings = [];
        allTeamsSet.forEach(teamName => {
            const teamResults = cumulativeResults.filter(r => 
                r.homeTeam === teamName || r.awayTeam === teamName
            );
            
            let points = 0;
            let fantasyPoints = 0;
            let goalsFor = 0;
            let goalsAgainst = 0;
            
            teamResults.forEach(r => {
                if (r.homeTeam === teamName) {
                    // Partita in casa
                    if (r.result === '1') points += 3;
                    else if (r.result === 'X') points += 1;
                    
                    if (r.score && r.score.includes('-')) {
                        const [home, away] = r.score.split('-').map(g => parseInt(g.trim(), 10));
                        if (!isNaN(home) && !isNaN(away)) {
                            goalsFor += home;
                            goalsAgainst += away;
                        }
                    }
                    
                    if (r.homePoints) fantasyPoints += r.homePoints;
                } else {
                    // Partita in trasferta
                    if (r.result === '2') points += 3;
                    else if (r.result === 'X') points += 1;
                    
                    if (r.score && r.score.includes('-')) {
                        const [home, away] = r.score.split('-').map(g => parseInt(g.trim(), 10));
                        if (!isNaN(home) && !isNaN(away)) {
                            goalsFor += away;
                            goalsAgainst += home;
                        }
                    }
                    
                    if (r.awayPoints) fantasyPoints += r.awayPoints;
                }
            });
            
            standings.push({
                team: teamName,
                points: points,
                fantasyPoints: fantasyPoints,
                goalDifference: goalsFor - goalsAgainst,
                goalsFor: goalsFor,
                goalsAgainst: goalsAgainst
            });
        });
        
        // Ordina usando lo stesso criterio della classifica principale
        standings.sort((a, b) => {
            if (b.points !== a.points) return b.points - a.points;
            if (b.fantasyPoints !== a.fantasyPoints) return b.fantasyPoints - a.fantasyPoints;
            if (b.goalDifference !== a.goalDifference) return b.goalDifference - a.goalDifference;
            if (b.goalsFor !== a.goalsFor) return b.goalsFor - a.goalsFor;
            if (a.goalsAgainst !== b.goalsAgainst) return a.goalsAgainst - b.goalsAgainst;
            return 0;
        });
        
        // Salva la posizione di ogni squadra in questa giornata
        standings.forEach((team, index) => {
            teamTrends.get(team.team).push({
                giornata: giornata,
                position: index + 1,
                points: team.points
            });
        });
    });
    
    return {
        giornate: sortedGiornate,
        teamTrends: teamTrends
    };
};

// Funzione per renderizzare l'andamento della classifica
let standingsTrendChart = null; // Variabile globale per il grafico

const renderStandingsTrend = () => {
    const canvas = document.getElementById('standings-trend-chart');
    const placeholder = document.getElementById('standings-trend-placeholder');
    
    if (!canvas) return;
    
    const trendData = calculateStandingsTrend();
    
    if (!trendData) {
        if (placeholder) placeholder.style.display = 'flex';
        if (canvas) canvas.style.display = 'none';
        return;
    }
    
    const { giornate, teamTrends } = trendData;
    
    // Nascondi placeholder e mostra canvas
    if (placeholder) placeholder.style.display = 'none';
    if (canvas) canvas.style.display = 'block';
    
    // Distruggi il grafico precedente se esiste
    if (standingsTrendChart) {
        standingsTrendChart.destroy();
    }
    
    // Colori per ogni squadra
    const teamColors = [
        { border: '#3b82f6', bg: 'rgba(59, 130, 246, 0.1)' },  // Blue
        { border: '#ef4444', bg: 'rgba(239, 68, 68, 0.1)' },   // Red
        { border: '#10b981', bg: 'rgba(16, 185, 129, 0.1)' },  // Green
        { border: '#f59e0b', bg: 'rgba(245, 158, 11, 0.1)' },  // Yellow
        { border: '#8b5cf6', bg: 'rgba(139, 92, 246, 0.1)' },  // Purple
        { border: '#ec4899', bg: 'rgba(236, 72, 153, 0.1)' },  // Pink
        { border: '#14b8a6', bg: 'rgba(20, 184, 166, 0.1)' },  // Teal
        { border: '#f97316', bg: 'rgba(249, 115, 22, 0.1)' },  // Orange
        { border: '#06b6d4', bg: 'rgba(6, 182, 212, 0.1)' },   // Cyan
        { border: '#84cc16', bg: 'rgba(132, 204, 22, 0.1)' }   // Lime
    ];
    
    // Ordina le squadre per posizione finale
    const finalStandings = Array.from(teamTrends.entries())
        .map(([team, trend]) => ({
            team: team,
            finalPosition: trend[trend.length - 1].position,
            trend: trend
        }))
        .sort((a, b) => a.finalPosition - b.finalPosition);
    
    // Prepara i dataset per Chart.js
    const datasets = finalStandings.map(({ team, trend }, idx) => {
        const color = teamColors[idx % teamColors.length];
        
        // Crea array di posizioni per ogni giornata
        const positions = giornate.map(g => {
            const data = trend.find(t => t.giornata === g);
            return data ? data.position : null;
        });
        
        return {
            label: team,
            data: positions,
            borderColor: color.border,
            backgroundColor: color.bg,
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6,
            tension: 0.1,
            fill: false
        };
    });
    
    // Crea il grafico
    const ctx = canvas.getContext('2d');
    standingsTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: giornate.map(g => `G${g}`),
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: window.innerWidth < 768 ? 1 : 2,
            interaction: {
                mode: 'index',
                intersect: false,
            },
            plugins: {
                title: {
                    display: false
                },
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        color: '#e0e7ff',
                        padding: 12,
                        font: {
                            size: window.innerWidth < 768 ? 10 : 12
                        },
                        usePointStyle: true,
                        pointStyle: 'circle'
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(15, 23, 42, 0.95)',
                    titleColor: '#e0e7ff',
                    bodyColor: '#e0e7ff',
                    borderColor: '#1e3a8a',
                    borderWidth: 1,
                    padding: 12,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            const teamName = context.dataset.label;
                            const position = context.parsed.y;
                            return `${teamName}: ${position}¬∞ posto`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    reverse: true, // Inverti l'asse Y (1¬∞ in alto)
                    beginAtZero: false,
                    ticks: {
                        color: '#9ca3af',
                        stepSize: 1,
                        callback: function(value) {
                            return value + '¬∞';
                        }
                    },
                    grid: {
                        color: 'rgba(75, 85, 99, 0.3)',
                        drawBorder: false
                    },
                    title: {
                        display: true,
                        text: 'Posizione',
                        color: '#9ca3af',
                        font: {
                            size: 12
                        }
                    }
                },
                x: {
                    ticks: {
                        color: '#9ca3af',
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: window.innerWidth < 768 ? 9 : 11
                        }
                    },
                    grid: {
                        color: 'rgba(75, 85, 99, 0.2)',
                        drawBorder: false
                    },
                    title: {
                        display: true,
                        text: 'Giornata',
                        color: '#9ca3af',
                        font: {
                            size: 12
                        }
                    }
                }
            }
        }
    });
};

// Funzione per calcolare le statistiche avanzate
const calculateStatistics = () => {
    const stats = {
        bestAttack: { team: null, goalsFor: 0 },
        bestDefense: { team: null, goalsAgainst: Infinity },
        bestGoalDifference: { team: null, goalDifference: -Infinity },
        worstGoalDifference: { team: null, goalDifference: Infinity },
        highestScore: { team: null, score: 0, opponent: null, giornata: null },
        lowestScore: { team: null, score: Infinity, opponent: null, giornata: null },
        biggestWin: { team: null, margin: 0, score: null, opponent: null, giornata: null },
        highestDraw: { homeTeam: null, awayTeam: null, score: 0, giornata: null },
        lowestDraw: { homeTeam: null, awayTeam: null, score: Infinity, giornata: null },
        mostGoalsMatch: { homeTeam: null, awayTeam: null, totalGoals: 0, score: null, giornata: null },
        mostGoalsGiornata: { giornata: null, totalGoals: 0 },
        leastGoalsGiornata: { giornata: null, totalGoals: Infinity }
    };
    
    // Raccoglie tutte le squadre
    const teamsSet = new Set();
    allResults.forEach(result => {
        teamsSet.add(result.homeTeam);
        teamsSet.add(result.awayTeam);
    });
    
    // Analizza ogni squadra
    teamsSet.forEach(teamName => {
        const teamStats = calculateTeamStats(teamName);
        
        // Miglior attacco (pi√π gol fatti)
        if (teamStats.goalsFor > stats.bestAttack.goalsFor) {
            stats.bestAttack = { team: teamName, goalsFor: teamStats.goalsFor };
        }
        
        // Miglior difesa (meno gol subiti)
        if (teamStats.goalsAgainst < stats.bestDefense.goalsAgainst) {
            stats.bestDefense = { team: teamName, goalsAgainst: teamStats.goalsAgainst };
        }
        
        // Miglior differenza reti
        // Miglior differenza reti
        if (teamStats.goalDifference > stats.bestGoalDifference.goalDifference) {
            stats.bestGoalDifference = { team: teamName, goalDifference: teamStats.goalDifference };
        }
        
        // Peggior differenza reti
        if (teamStats.goalDifference < stats.worstGoalDifference.goalDifference) {
            stats.worstGoalDifference = { team: teamName, goalDifference: teamStats.goalDifference };
        }
    });
    
    // Trova il punteggio pi√π alto e pi√π basso in una singola partita, la vittoria pi√π larga, pareggi, maggior gol
    allResults.forEach(result => {
        const homeScore = result.homePoints || 0;
        const awayScore = result.awayPoints || 0;
        
        // Controlla punteggio casa per massimo
        if (homeScore > stats.highestScore.score) {
            stats.highestScore = {
                team: result.homeTeam,
                score: homeScore,
                opponent: result.awayTeam,
                giornata: result.giornata
            };
        }
        
        // Controlla punteggio ospite per massimo
        if (awayScore > stats.highestScore.score) {
            stats.highestScore = {
                team: result.awayTeam,
                score: awayScore,
                opponent: result.homeTeam,
                giornata: result.giornata
            };
        }
        
        // Controlla punteggio minimo (escludendo 0 che potrebbe essere dato non valido)
        if (homeScore > 0 && homeScore < stats.lowestScore.score) {
            stats.lowestScore = {
                team: result.homeTeam,
                score: homeScore,
                opponent: result.awayTeam,
                giornata: result.giornata
            };
        }
        
        if (awayScore > 0 && awayScore < stats.lowestScore.score) {
            stats.lowestScore = {
                team: result.awayTeam,
                score: awayScore,
                opponent: result.homeTeam,
                giornata: result.giornata
            };
        }
        
        // Vittoria con il margine pi√π ampio
        const margin = Math.abs(homeScore - awayScore);
        if (result.result !== 'X' && margin > stats.biggestWin.margin) {
            const winner = result.result === '1' ? result.homeTeam : result.awayTeam;
            const loser = result.result === '1' ? result.awayTeam : result.homeTeam;
            stats.biggestWin = {
                team: winner,
                margin: margin,
                score: `${Math.max(homeScore, awayScore).toFixed(1)}-${Math.min(homeScore, awayScore).toFixed(1)}`,
                opponent: loser,
                giornata: result.giornata
            };
        }
        
        // Pareggi con punteggi alti e bassi
        if (result.result === 'X') {
            const drawScore = homeScore; // In caso di pareggio homeScore === awayScore
            
            if (drawScore > stats.highestDraw.score) {
                stats.highestDraw = {
                    homeTeam: result.homeTeam,
                    awayTeam: result.awayTeam,
                    score: drawScore,
                    giornata: result.giornata
                };
            }
            
            if (drawScore > 0 && drawScore < stats.lowestDraw.score) {
                stats.lowestDraw = {
                    homeTeam: result.homeTeam,
                    awayTeam: result.awayTeam,
                    score: drawScore,
                    giornata: result.giornata
                };
            }
        }
        
        // Partita con il maggior numero di gol (dal campo score, non dai punti)
        if (result.score && result.score.includes('-')) {
            const [homeGoals, awayGoals] = result.score.split('-').map(g => parseInt(g.trim(), 10));
            const totalGoals = homeGoals + awayGoals;
            
            if (totalGoals > stats.mostGoalsMatch.totalGoals) {
                stats.mostGoalsMatch = {
                    homeTeam: result.homeTeam,
                    awayTeam: result.awayTeam,
                    totalGoals: totalGoals,
                    score: result.score,
                    giornata: result.giornata
                };
            }
        }
    });
    
    // Giornate con maggior e minor numero di gol (somma dei gol effettivi, non dei punti)
    const giornateGoals = {};
    allResults.forEach(result => {
        const giornata = result.giornata;
        if (!giornateGoals[giornata]) {
            giornateGoals[giornata] = 0;
        }
        
        // Estrai i gol dal campo score
        if (result.score && result.score.includes('-')) {
            const [homeGoals, awayGoals] = result.score.split('-').map(g => parseInt(g.trim(), 10));
            giornateGoals[giornata] += homeGoals + awayGoals;
        }
    });
    
    Object.entries(giornateGoals).forEach(([giornata, totalGoals]) => {
        if (totalGoals > stats.mostGoalsGiornata.totalGoals) {
            stats.mostGoalsGiornata = { giornata, totalGoals };
        }
        
        if (totalGoals < stats.leastGoalsGiornata.totalGoals) {
            stats.leastGoalsGiornata = { giornata, totalGoals };
        }
    });
    
    return stats;
};

// Funzione per renderizzare le statistiche
const renderStatistics = () => {
    const container = document.getElementById('statistics-container');
    if (!container) return;
    
    if (allResults.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-center py-4 col-span-full">Nessun dato disponibile</p>';
        return;
    }
    
    const stats = calculateStatistics();
    
    container.innerHTML = `
        <!-- STATISTICHE PRINCIPALI (sempre visibili) -->
        <!-- Miglior Attacco -->
        <div class="bg-gradient-to-br from-red-900/30 to-red-800/20 border border-red-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-red-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12.395 2.553a1 1 0 00-1.45-.385c-.345.23-.614.558-.822.88-.214.33-.403.713-.57 1.116-.334.804-.614 1.768-.84 2.734a31.365 31.365 0 00-.613 3.58 2.64 2.64 0 01-.945-1.067c-.328-.68-.398-1.534-.398-2.654A1 1 0 005.05 6.05 6.981 6.981 0 003 11a7 7 0 1011.95-4.95c-.592-.591-.98-.985-1.348-1.467-.363-.476-.724-1.063-1.207-2.03zM12.12 15.12A3 3 0 017 13s.879.5 2.5.5c0-1 .5-4 1.25-4.5.5 1 .786 1.293 1.371 1.879A2.99 2.99 0 0113 13a2.99 2.99 0 01-.879 2.121z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-red-300 uppercase">Miglior Attacco</h4>
            </div>
            ${stats.bestAttack.team ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.bestAttack.team)}" alt="${stats.bestAttack.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.bestAttack.team}</p>
                        <p class="text-2xl font-bold text-red-400">${stats.bestAttack.goalsFor} gol</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Miglior Difesa -->
        <div class="bg-gradient-to-br from-blue-900/30 to-blue-800/20 border border-blue-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-blue-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-blue-300 uppercase">Miglior Difesa</h4>
            </div>
            ${stats.bestDefense.team ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.bestDefense.team)}" alt="${stats.bestDefense.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.bestDefense.team}</p>
                        <p class="text-2xl font-bold text-blue-400">${stats.bestDefense.goalsAgainst} gol subiti</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Punteggio Pi√π Alto -->
        <div class="bg-gradient-to-br from-purple-900/30 to-purple-800/20 border border-purple-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-purple-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                </svg>
                <h4 class="text-sm font-bold text-purple-300 uppercase">Punteggio Pi√π Alto</h4>
            </div>
            ${stats.highestScore.team ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.highestScore.team)}" alt="${stats.highestScore.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.highestScore.team}</p>
                        <p class="text-2xl font-bold text-purple-400">${stats.highestScore.score.toFixed(1)} punti</p>
                        <p class="text-xs text-gray-400">vs ${stats.highestScore.opponent} - Giornata ${stats.highestScore.giornata}</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Vittoria con Margine Pi√π Ampio -->
        <div class="bg-gradient-to-br from-yellow-900/30 to-yellow-800/20 border border-yellow-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-yellow-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"></path>
                </svg>
                <h4 class="text-sm font-bold text-yellow-300 uppercase">Vittoria Pi√π Larga</h4>
            </div>
            ${stats.biggestWin.team ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.biggestWin.team)}" alt="${stats.biggestWin.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.biggestWin.team}</p>
                        <p class="text-2xl font-bold text-yellow-400">+${stats.biggestWin.margin.toFixed(1)} punti</p>
                        <p class="text-xs text-gray-400">${stats.biggestWin.score} vs ${stats.biggestWin.opponent} - G.${stats.biggestWin.giornata}</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Pulsante Mostra/Nascondi altre statistiche -->
        <div class="col-span-full flex justify-center mt-2">
            <button onclick="toggleAdditionalStats()" id="toggle-stats-btn" class="btn-secondary px-6 py-2 flex items-center gap-2">
                <svg id="toggle-stats-icon" class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
                <span id="toggle-stats-text">Vedi altre statistiche</span>
            </button>
        </div>
        
        <!-- STATISTICHE AGGIUNTIVE (nascoste di default) -->
        <div id="additional-stats" class="hidden col-span-full grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
        
        <!-- Miglior Differenza Reti -->
        <div class="bg-gradient-to-br from-green-900/30 to-green-800/20 border border-green-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-green-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12 7a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0V8.414l-4.293 4.293a1 1 0 01-1.414 0L8 10.414l-4.293 4.293a1 1 0 01-1.414-1.414l5-5a1 1 0 011.414 0L11 10.586 14.586 7H12z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-green-300 uppercase">Miglior Diff. Reti</h4>
            </div>
            ${stats.bestGoalDifference.team ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.bestGoalDifference.team)}" alt="${stats.bestGoalDifference.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.bestGoalDifference.team}</p>
                        <p class="text-2xl font-bold text-green-400">${stats.bestGoalDifference.goalDifference > 0 ? '+' : ''}${stats.bestGoalDifference.goalDifference}</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Peggior Differenza Reti -->
        <div class="bg-gradient-to-br from-red-900/30 to-red-800/20 border border-red-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-red-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12 13a1 1 0 100 2h5a1 1 0 001-1V9a1 1 0 10-2 0v2.586l-4.293-4.293a1 1 0 00-1.414 0L8 9.586 3.707 5.293a1 1 0 00-1.414 1.414l5 5a1 1 0 001.414 0L11 9.414 14.586 13H12z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-red-300 uppercase">Peggior Diff. Reti</h4>
            </div>
            ${stats.worstGoalDifference.team && stats.worstGoalDifference.goalDifference !== Infinity ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.worstGoalDifference.team)}" alt="${stats.worstGoalDifference.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.worstGoalDifference.team}</p>
                        <p class="text-2xl font-bold text-red-400">${stats.worstGoalDifference.goalDifference}</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Punteggio Pi√π Basso -->
        <div class="bg-gradient-to-br from-gray-900/30 to-gray-800/20 border border-gray-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-gray-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M12 13a1 1 0 100 2h5a1 1 0 001-1V9a1 1 0 10-2 0v2.586l-4.293-4.293a1 1 0 00-1.414 0L8 9.586 3.707 5.293a1 1 0 00-1.414 1.414l5 5a1 1 0 001.414 0L11 9.414 14.586 13H12z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-gray-300 uppercase">Punteggio Pi√π Basso</h4>
            </div>
            ${stats.lowestScore.team && stats.lowestScore.score !== Infinity ? `
                <div class="flex items-center space-x-3">
                    <img src="${getTeamLogo(stats.lowestScore.team)}" alt="${stats.lowestScore.team}" class="w-10 h-10 object-contain" onerror="this.style.display='none'">
                    <div>
                        <p class="text-lg font-bold text-white">${stats.lowestScore.team}</p>
                        <p class="text-2xl font-bold text-gray-400">${stats.lowestScore.score.toFixed(1)} punti</p>
                        <p class="text-xs text-gray-400">vs ${stats.lowestScore.opponent} - Giornata ${stats.lowestScore.giornata}</p>
                    </div>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Pareggio con Punteggio Pi√π Alto -->
        <div class="bg-gradient-to-br from-orange-900/30 to-orange-800/20 border border-orange-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-orange-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11 4a1 1 0 10-2 0v4a1 1 0 102 0V7zm-3 1a1 1 0 10-2 0v3a1 1 0 102 0V8zM8 9a1 1 0 00-2 0v2a1 1 0 102 0V9z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-orange-300 uppercase">Pareggio Pi√π Alto</h4>
            </div>
            ${stats.highestDraw.homeTeam ? `
                <div>
                    <p class="text-lg font-bold text-white">${stats.highestDraw.homeTeam} vs ${stats.highestDraw.awayTeam}</p>
                    <p class="text-2xl font-bold text-orange-400">${stats.highestDraw.score.toFixed(1)}-${stats.highestDraw.score.toFixed(1)}</p>
                    <p class="text-xs text-gray-400">Giornata ${stats.highestDraw.giornata}</p>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Pareggio con Punteggio Pi√π Basso -->
        <div class="bg-gradient-to-br from-cyan-900/30 to-cyan-800/20 border border-cyan-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-cyan-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M3 3a1 1 0 000 2v8a2 2 0 002 2h2.586l-1.293 1.293a1 1 0 101.414 1.414L10 15.414l2.293 2.293a1 1 0 001.414-1.414L12.414 15H15a2 2 0 002-2V5a1 1 0 100-2H3zm11 4a1 1 0 10-2 0v4a1 1 0 102 0V7zm-3 1a1 1 0 10-2 0v3a1 1 0 102 0V8zM8 9a1 1 0 00-2 0v2a1 1 0 102 0V9z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-cyan-300 uppercase">Pareggio Pi√π Basso</h4>
            </div>
            ${stats.lowestDraw.homeTeam && stats.lowestDraw.score !== Infinity ? `
                <div>
                    <p class="text-lg font-bold text-white">${stats.lowestDraw.homeTeam} vs ${stats.lowestDraw.awayTeam}</p>
                    <p class="text-2xl font-bold text-cyan-400">${stats.lowestDraw.score.toFixed(1)}-${stats.lowestDraw.score.toFixed(1)}</p>
                    <p class="text-xs text-gray-400">Giornata ${stats.lowestDraw.giornata}</p>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Partita con Pi√π Gol -->
        <div class="bg-gradient-to-br from-pink-900/30 to-pink-800/20 border border-pink-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-pink-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-pink-300 uppercase">Partita con Pi√π Gol</h4>
            </div>
            ${stats.mostGoalsMatch.homeTeam ? `
                <div>
                    <p class="text-lg font-bold text-white">${stats.mostGoalsMatch.homeTeam} vs ${stats.mostGoalsMatch.awayTeam}</p>
                    <p class="text-2xl font-bold text-pink-400">${stats.mostGoalsMatch.totalGoals} gol totali</p>
                    <p class="text-xs text-gray-400">${stats.mostGoalsMatch.score} - Giornata ${stats.mostGoalsMatch.giornata}</p>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Giornata con Pi√π Gol -->
        <div class="bg-gradient-to-br from-indigo-900/30 to-indigo-800/20 border border-indigo-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-indigo-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-indigo-300 uppercase">Giornata con Pi√π Gol</h4>
            </div>
            ${stats.mostGoalsGiornata.giornata ? `
                <div>
                    <p class="text-lg font-bold text-white">Giornata ${stats.mostGoalsGiornata.giornata}</p>
                    <p class="text-2xl font-bold text-indigo-400">${stats.mostGoalsGiornata.totalGoals} gol totali</p>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        <!-- Giornata con Meno Gol -->
        <div class="bg-gradient-to-br from-teal-900/30 to-teal-800/20 border border-teal-700/50 rounded-lg p-4">
            <div class="flex items-center mb-2">
                <svg class="w-6 h-6 text-teal-400 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                </svg>
                <h4 class="text-sm font-bold text-teal-300 uppercase">Giornata con Meno Gol</h4>
            </div>
            ${stats.leastGoalsGiornata.giornata && stats.leastGoalsGiornata.totalGoals !== Infinity ? `
                <div>
                    <p class="text-lg font-bold text-white">Giornata ${stats.leastGoalsGiornata.giornata}</p>
                    <p class="text-2xl font-bold text-teal-400">${stats.leastGoalsGiornata.totalGoals} gol totali</p>
                </div>
            ` : '<p class="text-gray-400 text-sm">Dati non disponibili</p>'}
        </div>
        
        </div>
    `;
};

// Funzione per mostrare/nascondere le statistiche aggiuntive
window.toggleAdditionalStats = () => {
    const additionalStats = document.getElementById('additional-stats');
    const toggleBtn = document.getElementById('toggle-stats-btn');
    const toggleText = document.getElementById('toggle-stats-text');
    const toggleIcon = document.getElementById('toggle-stats-icon');
    
    if (additionalStats && toggleBtn && toggleText && toggleIcon) {
        if (additionalStats.classList.contains('hidden')) {
            // Mostra
            additionalStats.classList.remove('hidden');
            toggleText.textContent = 'Nascondi statistiche';
            toggleIcon.style.transform = 'rotate(180deg)';
        } else {
            // Nascondi
            additionalStats.classList.add('hidden');
            toggleText.textContent = 'Vedi altre statistiche';
            toggleIcon.style.transform = 'rotate(0deg)';
        }
    }
};

        window.calculateAndSaveMatch = async () => {
             if (!isUserAdmin) return;
             const homeTeam = document.getElementById('new-match-home-team').value;
             const awayTeam = document.getElementById('new-match-away-team').value;
             const date = document.getElementById('new-match-date').value;
 
             if (!homeTeam || !awayTeam || homeTeam === awayTeam || !date) {
                 messageBox("Seleziona due squadre diverse e una data.");
                 return;
             }
             
             const odds = calculateOdds(homeTeam, awayTeam);
            // Recupera tutte le partite aperte e determina la prossima giornata disponibile
            const openMatchesSnapshot = await getDocs(query(getMatchesCollectionRef(), where('status', '==', 'open')));
            let nextGiornata = 1;
            if (!openMatchesSnapshot.empty) {
                 const maxGiornata = openMatchesSnapshot.docs.reduce((max, d) => {
                     const g = parseInt(d.data().giornata || '0', 10) || 0;
                     return Math.max(max, g);
                 }, 0);
                 // prossima giornata libera = max + 1
                 nextGiornata = Math.max(1, maxGiornata + 1);
            }
 
             try {
                 await addDoc(getMatchesCollectionRef(), {
                     homeTeam,
                     awayTeam,
                     date,
                     odds, // { '1': 2.50, 'X': 3.00, '2': 3.50 }
                     status: 'open',
                     score: null, // Nuovo campo score, nullo finch√© non chiusa
                     giornata: nextGiornata.toString(),
                     createdAt: new Date().toISOString()
                 });
                 messageBox(`Partita ${homeTeam} vs ${awayTeam} aperta per la Giornata ${nextGiornata} con quote: 1=${odds['1']}, X=${odds['X']}, 2=${odds['2']}`);
             } catch (error) {
                 console.error("Errore salvataggio partita:", error);
                 messageBox("Errore nel salvataggio della partita aperta.");
             }
         };

        // --- Chiusura Partita Admin ---
        // Funzione per liquidare le scommesse di una giornata
        const liquidateGiornataBets = async (giornata) => {
            try {
                const qBets = query(
                    getGiornataBetsCollectionRef(),
                    where('giornata', '==', giornata.toString())
                );
                const betsSnapshot = await getDocs(qBets);
                
                // Ottieni i match chiusi della giornata
                const qMatches = query(
                    getMatchesCollectionRef(),
                    where('giornata', '==', giornata.toString()),
                    where('status', '==', 'closed')
                );
                const matchesSnapshot = await getDocs(qMatches);
                const closedMatches = new Map(
                    matchesSnapshot.docs.map(doc => [doc.id, doc.data()])
                );

                // Batch write per aggiornare i crediti degli utenti
                const batch = writeBatch(db);
                const userUpdates = new Map(); // Map per aggregare le vincite per utente

                // Processa ogni scommessa
                betsSnapshot.docs.forEach(betDoc => {
                    const bet = betDoc.data();
                    const match = closedMatches.get(bet.matchId);
                    
                    if (match && match.result) {
                        const userId = bet.userId;
                        let creditsChange = -bet.stake; // Inizialmente sottrai la puntata
                        
                        // Se la previsione era corretta
                        if (bet.prediction === match.result) {
                            // Calcola la vincita (puntata * quota)
                            const win = bet.stake * parseFloat(bet.odds);
                            creditsChange += win;
                        }

                        // Aggrega le modifiche ai crediti per utente
                        userUpdates.set(
                            userId, 
                            (userUpdates.get(userId) || 0) + creditsChange
                        );
                    }
                });

                // Applica gli aggiornamenti dei crediti
                for (const [userId, creditsChange] of userUpdates) {
                    const userRef = doc(getUsersCollectionRef(), userId);
                    const userSnap = await getDoc(userRef);
                    if (userSnap.exists()) {
                        const currentCredits = userSnap.data().credits || 0;
                        batch.update(userRef, {
                            credits: currentCredits + creditsChange
                        });
                    }
                }

                // Esegui il batch
                await batch.commit();

                messageBox(`Scommesse liquidate per la giornata ${giornata}. ${userUpdates.size} utenti aggiornati.`);
                return true;
            } catch (error) {
                console.error("Errore liquidazione scommesse:", error);
                messageBox(`Errore durante la liquidazione delle scommesse: ${error.message}`);
                return false;
            }
        };

        window.closeMatchAndSaveScore = async () => {
            if (!isUserAdmin) return;

            const matchId = document.getElementById('match-to-close-select').value;
            const finalScore = document.getElementById('final-score-input').value.trim();

            if (!matchId) {
                messageBox("Seleziona una partita da chiudere.");
                return;
            }

            if (!finalScore || !finalScore.match(/^\d+-\d+$/)) {
                 messageBox("Inserisci il punteggio finale nel formato corretto (es: 3-1).");
                 return;
            }
            
            const [homeGoals, awayGoals] = finalScore.split('-').map(g => parseInt(g.trim(), 10));

            let result;
            if (homeGoals > awayGoals) {
                result = '1';
            } else if (homeGoals < awayGoals) {
                result = '2';
            } else {
                result = 'X';
            }

            try {
                const matchRef = doc(getMatchesCollectionRef(), matchId);
                const matchData = (await getDoc(matchRef)).data();
                const giornata = matchData.giornata;
                
                // 1. Chiudi il match
                await updateDoc(matchRef, {
                    status: 'closed',
                    score: finalScore,
                    result: result
                });

                // 2. Verifica se tutti i match della giornata sono chiusi
                const qOpenMatches = query(
                    getMatchesCollectionRef(),
                    where('giornata', '==', giornata),
                    where('status', '==', 'open')
                );
                const openMatchesSnap = await getDocs(qOpenMatches);

                // Se non ci sono pi√π partite aperte nella giornata
                if (openMatchesSnap.empty) {
                    // 3. Liquida tutte le scommesse della giornata
                    const liquidated = await liquidateGiornataBets(giornata);
                    if (liquidated) {
                        messageBox(`Giornata ${giornata} completata! Scommesse liquidate e crediti aggiornati.`);
                    }
                } else {
                    messageBox(`Partita chiusa: ${finalScore}. Rimangono ancora ${openMatchesSnap.size} partite da chiudere per la giornata ${giornata}.`);
                }

                document.getElementById('final-score-input').value = '';

            } catch (error) {
                console.error("Errore chiusura partita:", error);
                messageBox(`Errore durante la chiusura della partita: ${error.message}`);
            }
        };


        // --- Gestione Scommesse Utente (MODIFICATA PER SCOMMESSA DI GRUPPO) ---
        
        // 1. Registra localmente la previsione per un singolo match
        window.recordPrediction = (matchId, prediction) => {
            // Verifica se l'utente ha gi√† scommesse confermate per questa giornata
            const hasConfirmedBets = openMatches.some(m => m.userBet && m.userBet.stake > 0);
            if (hasConfirmedBets) {
                messageBox("Non puoi modificare le scommesse dopo averle confermate per questa giornata.");
                return;
            }

            const matchContainer = document.getElementById(`match-${matchId}`);
            // Rimuovi la classe 'local-selected' da tutte le opzioni di questo match
            matchContainer.querySelectorAll('.bet-option').forEach(el => {
                el.classList.remove('local-selected');
            });
            
            const selectedElement = matchContainer.querySelector(`[data-match-id="${matchId}"][data-prediction="${prediction}"]`);
            
            // Aggiorna sempre la previsione (no toggle)
            currentPredictions[matchId] = prediction;
            selectedElement.classList.add('local-selected');

            updateGiornataBetButton();
        };

        // Funzione di utilit√† per abilitare/disabilitare il pulsante di salvataggio
        window.updateGiornataBetButton = () => {
            const button = document.getElementById('place-giornata-bet-button');
            const stakeInput = document.getElementById('bet-stake-input');
            const winPreviewEl = document.getElementById('win-preview');
            
            if (!button || !stakeInput) return;

            const requiredMatches = openMatches.length;
            const predictedMatches = Object.keys(currentPredictions).length;
            const stake = parseInt(stakeInput.value, 10);
            
            // Calcola la vincita potenziale (puntata √ó quota totale)
            let potentialWin = 0;
            let quotaTotale = 1;
            
            if (predictedMatches > 0 && stake > 0) {
                openMatches.forEach(match => {
                    const prediction = currentPredictions[match.id];
                    if (prediction && match.odds && match.odds[prediction]) {
                        const quota = parseFloat(match.odds[prediction]);
                        quotaTotale *= quota;
                    }
                });
                
                // Vincita = Puntata totale √ó Quota totale
                potentialWin = stake * quotaTotale;
            }
            
            // Aggiorna l'anteprima della vincita
            if (winPreviewEl) {
                if (predictedMatches === requiredMatches && stake > 0) {
                    const profitto = potentialWin - stake;
                    
                    winPreviewEl.innerHTML = `
                        <div class="bg-gray-800 border border-gray-700 rounded-lg p-4">
                            <h4 class="text-sm font-semibold text-gray-400 mb-2">Anteprima Vincita</h4>
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <p class="text-xs text-gray-500">Puntata Totale</p>
                                    <p class="text-lg font-bold text-white">${stake.toFixed(2)} Cr</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Quota Totale</p>
                                    <p class="text-lg font-bold text-blue-400">${quotaTotale.toFixed(2)}</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Vincita Potenziale</p>
                                    <p class="text-xl font-bold text-green-400">${potentialWin.toFixed(2)} Cr</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Profitto Netto</p>
                                    <p class="text-xl font-bold ${profitto >= 0 ? 'text-green-400' : 'text-red-400'}">${profitto >= 0 ? '+' : ''}${profitto.toFixed(2)} Cr</p>
                                </div>
                            </div>
                            <div class="mt-3 pt-3 border-t border-gray-700">
                                <p class="text-xs text-gray-500 mb-1">Quote selezionate:</p>
                                <div class="flex flex-wrap gap-2">
                                    ${openMatches.map(m => {
                                        const pred = currentPredictions[m.id];
                                        return pred ? `<span class="text-xs bg-gray-700 px-2 py-1 rounded">${m.homeTeam.substring(0,10)} vs ${m.awayTeam.substring(0,10)}: ${pred} @ ${m.odds[pred]}</span>` : '';
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    winPreviewEl.innerHTML = `
                        <div class="bg-gray-800 border border-gray-700 rounded-lg p-4 text-center">
                            <p class="text-sm text-gray-500">Seleziona tutte le partite e inserisci la puntata per vedere l'anteprima della vincita</p>
                        </div>
                    `;
                }
            }
            
            if (requiredMatches === 0) {
                button.disabled = true;
                button.textContent = "Nessuna partita aperta per scommettere.";
                return;
            }

            // Verifica se l'utente ha gi√† scommesse confermate
            const hasConfirmedBets = openMatches.some(m => m.userBet && m.userBet.stake > 0);
            if (hasConfirmedBets) {
                button.disabled = true;
                button.textContent = "Hai gi√† confermato le scommesse per questa giornata";
                button.classList.replace('btn-primary', 'btn-secondary');
                return;
            }

            // Aggiorna il testo del pulsante in base allo stato
            if (predictedMatches === requiredMatches) {
                const totalStake = stake;
                if (totalStake > userCredits || totalStake <= 0) {
                    button.disabled = true;
                    button.textContent = totalStake > userCredits ? 
                        `Crediti insufficienti! (${totalStake} Cr richiesti)` : 
                        'Inserisci una puntata valida';
                    button.classList.replace('btn-primary', 'btn-danger');
                } else {
                    button.disabled = false;
                    button.textContent = `Conferma Scommesse Giornata (${totalStake} Crediti)`;
                    button.classList.replace('btn-danger', 'btn-primary');
                }
            } else {
                button.disabled = true;
                button.textContent = `Devi selezionare TUTTE le partite (${predictedMatches}/${requiredMatches})`;
                button.classList.replace('btn-primary', 'btn-secondary');
                button.classList.remove('btn-danger');
            }
        };

        // 2. Salva tutte le predizioni per la giornata
        window.placeBetForGiornata = async () => {
            console.log('placeBetForGiornata chiamato');
            
            const stakeInput = document.getElementById('bet-stake-input');
            const totalStake = parseInt(stakeInput.value, 10);
            
            const requiredMatches = openMatches.length;
            const predictedMatches = Object.keys(currentPredictions).length;
            
            const currentGiornata = nextGiornataNumber.toString();
            console.log('Stato scommessa:', {
                giornata: currentGiornata,
                requiredMatches,
                predictedMatches,
                totalStake,
                userCredits,
                currentPredictions
            });
            
            // CONTROLLO DEADLINE: Verifica se √® ancora possibile scommettere
            try {
                const deadlinePassed = await isDeadlinePassed(currentGiornata);
                if (deadlinePassed) {
                    const { deadline, confirmed } = await getGiornataDeadline(currentGiornata);
                    const status = confirmed ? 'confermato' : 'stimato';
                    messageBox(`‚è∞ SCOMMESSE CHIUSE!\n\nLa deadline per questa giornata √® scaduta.\nOrario di chiusura (${status}): ${deadline.toLocaleString('it-IT')}`);
                    return;
                }
            } catch (error) {
                console.error('Errore verifica deadline:', error);
                messageBox("Errore nella verifica della deadline. Riprova.");
                return;
            }
            
            // Verifica se ci sono gi√† scommesse SALVATE su Firestore per questa giornata
            try {
                const qExistingBets = query(
                    getGiornataBetsCollectionRef(),
                    where('userId', '==', userId),
                    where('giornata', '==', currentGiornata)
                );
                const existingBetsSnapshot = await getDocs(qExistingBets);
                
                if (!existingBetsSnapshot.empty) {
                    console.warn('Scommesse gi√† presenti per questa giornata:', existingBetsSnapshot.size);
                    messageBox("Hai gi√† piazzato le scommesse per questa giornata. Non puoi modificarle.");
                    return;
                }
            } catch (error) {
                console.error('Errore verifica scommesse esistenti:', error);
                messageBox("Errore durante la verifica delle scommesse esistenti.");
                return;
            }
            
            if (predictedMatches !== requiredMatches) {
                messageBox(`Devi selezionare OBBLIGATORIAMENTE un pronostico per tutte e ${requiredMatches} le partite della giornata.`);
                return;
            }
            
            if (totalStake <= 0 || isNaN(totalStake)) {
                messageBox("La puntata per la giornata deve essere un numero positivo.");
                return;
            }

            if (totalStake > userCredits) {
                messageBox(`Crediti insufficienti. La puntata totale (${totalStake} crediti) supera il saldo disponibile (${userCredits}).`);
                return;
            }
            
            // Chiedi conferma all'utente
            if (!confirm(`ATTENZIONE: Stai per confermare le scommesse per tutta la giornata.\nImporto totale: ${totalStake} crediti\nUna volta confermata, non potrai pi√π modificare le tue scelte.\n\nProcedere?`)) {
                console.log('Utente ha annullato la conferma');
                return;
            }
            
            const stakePerMatch = totalStake / requiredMatches;
            console.log('Puntata per partita:', stakePerMatch);

            try {
                 console.log('Inizio salvataggio scommesse...');
                 
                 // Crea UNA SOLA scommessa per la giornata con tutte le predictions
                 const predictions = [];
                 let totalOdds = 1;
                 
                 openMatches.forEach(match => {
                     const matchId = match.id;
                     const prediction = currentPredictions[matchId];
                     
                     if (!prediction) {
                         console.warn('Previsione mancante per match:', matchId);
                         return;
                     }
                     
                     const odds = match.odds[prediction];
                     totalOdds *= odds; // Quota totale moltiplicativa
                     
                     predictions.push({
                         matchId: matchId,
                         homeTeam: match.homeTeam,
                         awayTeam: match.awayTeam,
                         prediction: prediction,
                         odds: odds,
                         date: match.date
                     });
                 });
                 
                 // Calcola vincita potenziale (puntata * quota totale)
                 const potentialWinnings = totalStake * totalOdds;
                 
                 console.log('Dettagli scommessa:', {
                     predictions: predictions.length,
                     quotaTotale: totalOdds.toFixed(2),
                     puntata: totalStake,
                     vincitaPotenziale: potentialWinnings.toFixed(2)
                 });
                 
                 // Salva UNA SOLA scommessa per la giornata
                 const betDocRef = doc(getGiornataBetsCollectionRef(), `${userId}_giornata_${currentGiornata}`);
                 
                 const betData = {
                    userId: userId,
                    giornata: currentGiornata,
                    predictions: predictions, // Array di tutte le predictions
                    stake: totalStake, // Puntata totale
                    quotaTotale: totalOdds, // Quota totale moltiplicativa
                    potentialWinnings: potentialWinnings, // Vincita potenziale
                    timestamp: new Date().toISOString(),
                    settled: false // Flag per liquidazione
                 };
                 
                 console.log('Salvataggio scommessa unica per giornata:', betData);
                 await setDoc(betDocRef, betData);
                 console.log('Scommessa salvata con successo su Firestore');

                 // Sottrai i crediti e aggiorna Firestore
                 console.log('Aggiornamento crediti...');
                 await adjustCredits(-totalStake);
                 console.log('Crediti aggiornati');

                 // Reset dello stato locale dopo il successo
                 currentPredictions = {};
                 
                 // Pulisci il campo di input
                 if (stakeInput) stakeInput.value = '';

                 messageBox(`Scommessa piazzata con successo per la Giornata ${currentGiornata}.\nPuntata totale: ${totalStake} crediti\nQuota totale: ${totalOdds.toFixed(2)}\nVincita potenziale: ${potentialWinnings.toFixed(2)} crediti`);
                 
                 // Ricarica la scommessa appena salvata e aggiorna le partite
                 console.log('Ricarica scommessa dopo salvataggio...');
                 const savedBetSnapshot = await getDoc(betDocRef);
                 if (savedBetSnapshot.exists()) {
                     const savedBet = savedBetSnapshot.data();
                     console.log('Scommessa ricaricata:', savedBet);
                     
                     // Aggiorna openMatches con i dati della scommessa salvata
                     openMatches = openMatches.map(match => {
                         const prediction = savedBet.predictions?.find(p => p.matchId === match.id);
                         if (prediction) {
                             match.userBet = {
                                 prediction: prediction.prediction,
                                 stake: savedBet.stake,
                                 odds: prediction.odds
                             };
                         }
                         return match;
                     });
                 }
                 
                 // Aggiorna la vista per mostrare la scommessa confermata
                 console.log('Aggiornamento vista dopo salvataggio...');
                 renderOpenMatches(openMatches, nextGiornataNumber);

            } catch (error) {
                console.error("Errore piazzamento scommessa:", error);
                messageBox(`Errore nel piazzamento della scommessa: ${error.message || error}`);
            }
        };


        // --- Rendering Countdown Deadline ---
        
        const renderBetDeadlineCountdown = async (giornata) => {
            const countdownEl = document.getElementById('bet-deadline-countdown');
            if (!countdownEl) return;
            
            try {
                const { deadline, confirmed, notes } = await getGiornataDeadline(giornata);
                const now = new Date();
                const isPast = now >= deadline;
                
                if (isPast) {
                    countdownEl.innerHTML = `
                        <div class="bg-red-900/30 border-l-4 border-red-500 p-4 rounded-lg">
                            <div class="flex items-center">
                                <svg class="w-6 h-6 text-red-400 mr-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path>
                                </svg>
                                <div>
                                    <p class="text-red-300 font-bold text-lg">‚è∞ SCOMMESSE CHIUSE</p>
                                    <p class="text-red-200 text-sm">La deadline per la Giornata ${giornata} √® scaduta il ${deadline.toLocaleString('it-IT')}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Calcola tempo rimanente
                const diff = deadline - now;
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                
                // Colore e icona in base al tempo rimanente
                let bgColor, borderColor, textColor, iconColor, statusIcon;
                if (days > 2) {
                    bgColor = 'bg-green-900/20';
                    borderColor = 'border-green-500';
                    textColor = 'text-green-300';
                    iconColor = 'text-green-400';
                    statusIcon = `<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>`;
                } else if (days > 0 || hours > 12) {
                    bgColor = 'bg-yellow-900/20';
                    borderColor = 'border-yellow-500';
                    textColor = 'text-yellow-300';
                    iconColor = 'text-yellow-400';
                    statusIcon = `<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>`;
                } else {
                    bgColor = 'bg-red-900/20';
                    borderColor = 'border-red-500';
                    textColor = 'text-red-300';
                    iconColor = 'text-red-400';
                    statusIcon = `<path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>`;
                }
                
                const confirmedBadge = confirmed 
                    ? `<span class="ml-2 px-2 py-1 bg-green-600 text-white text-xs rounded-full">‚úì Confermato</span>`
                    : `<span class="ml-2 px-2 py-1 bg-orange-600 text-white text-xs rounded-full">‚ö† Da confermare</span>`;
                
                // Aggiungi animazione se manca meno di 1 ora
                const urgentClass = (days === 0 && hours < 1) ? 'countdown-urgent' : '';
                
                countdownEl.innerHTML = `
                    <div class="${bgColor} border-l-4 ${borderColor} p-4 rounded-lg ${urgentClass}">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <svg class="w-6 h-6 ${iconColor} mr-3" fill="currentColor" viewBox="0 0 20 20">
                                    ${statusIcon}
                                </svg>
                                <div>
                                    <p class="${textColor} font-bold text-lg">
                                        Chiusura scommesse Giornata ${giornata}
                                        ${confirmedBadge}
                                    </p>
                                    <p class="text-gray-300 text-sm mt-1">
                                        ${deadline.toLocaleDateString('it-IT', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })} 
                                        alle ${deadline.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' })}
                                    </p>
                                    ${notes ? `<p class="text-gray-400 text-xs mt-1 italic">${notes}</p>` : ''}
                                </div>
                            </div>
                            <div class="text-right">
                                <p class="text-gray-400 text-xs mb-1">Tempo rimanente:</p>
                                <div class="flex space-x-2 text-center">
                                    ${days > 0 ? `
                                        <div class="bg-gray-800 px-3 py-2 rounded">
                                            <p class="${textColor} text-2xl font-bold">${days}</p>
                                            <p class="text-gray-400 text-xs">giorni</p>
                                        </div>
                                    ` : ''}
                                    <div class="bg-gray-800 px-3 py-2 rounded">
                                        <p class="${textColor} text-2xl font-bold">${hours}</p>
                                        <p class="text-gray-400 text-xs">ore</p>
                                    </div>
                                    <div class="bg-gray-800 px-3 py-2 rounded">
                                        <p class="${textColor} text-2xl font-bold">${minutes}</p>
                                        <p class="text-gray-400 text-xs">min</p>
                                    </div>
                                    ${days === 0 && hours < 1 ? `
                                        <div class="bg-gray-800 px-3 py-2 rounded">
                                            <p class="${textColor} text-2xl font-bold">${seconds}</p>
                                            <p class="text-gray-400 text-xs">sec</p>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Errore rendering countdown:', error);
                countdownEl.innerHTML = '';
            }
        };


        const renderOpenMatches = (matches, nextGiornata) => {
            console.log('renderOpenMatches chiamato con:', { 
                matches: matches?.map(m => ({
                    id: m.id,
                    homeTeam: m.homeTeam,
                    awayTeam: m.awayTeam,
                    giornata: m.giornata,
                    status: m.status,
                    result: m.result
                })),
                nextGiornata 
            });
            
            // Renderizza il countdown della deadline
            renderBetDeadlineCountdown(nextGiornata);
            
            // Avvia timer per aggiornare il countdown ogni secondo
            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(() => {
                renderBetDeadlineCountdown(nextGiornata);
            }, 1000);
            
            const listContainer = document.getElementById('open-matches-list');
            const noMatchesMessage = document.getElementById('no-open-matches');
            const stakeButton = document.getElementById('place-giornata-bet-button');
            
            if (!listContainer || !noMatchesMessage || !stakeButton) {
                console.error('Elementi UI mancanti:', {
                    listContainer: !!listContainer,
                    noMatchesMessage: !!noMatchesMessage,
                    stakeButton: !!stakeButton
                });
                return;
            }

            nextGiornataNumber = nextGiornata; // Aggiorna lo stato globale
            listContainer.innerHTML = '';
            
            // Verifica se ci sono gi√† scommesse confermate
            const hasConfirmedBets = matches.some(m => m.userBet && m.userBet.stake > 0);
            console.log('Stato scommesse:', { hasConfirmedBets, matchesCount: matches?.length });
            
            // Se ci sono scommesse confermate, disabilita input e mostra messaggio
            const stakeInputEl = document.getElementById('bet-stake-input');
            if (stakeInputEl) {
                stakeInputEl.disabled = hasConfirmedBets;
                if (hasConfirmedBets) {
                    stakeInputEl.value = '';
                    stakeInputEl.placeholder = 'Scommessa gi√† piazzata';
                }
            }
            
            // Se non ci sono scommesse confermate, resetta le predizioni locali
            if (!hasConfirmedBets) {
                currentPredictions = {}; 
            } else {
                // Se ci sono scommesse confermate, caricale nelle predizioni locali
                currentPredictions = matches.reduce((acc, match) => {
                    if (match.userBet && match.userBet.prediction) {
                        acc[match.id] = match.userBet.prediction;
                    }
                    return acc;
                }, {});
            }

            if (!matches || matches.length === 0) {
                noMatchesMessage.classList.remove('hidden');
                noMatchesMessage.textContent = 'Nessuna partita aperta per le scommesse al momento.';
                stakeButton.disabled = true;
                stakeButton.textContent = "Nessuna partita aperta";
                listContainer.innerHTML = ''; 
                return;
            }

            // Filtra solo le partite della prossima giornata (con parseInt sicuro)
            const filteredMatches = matches.filter(m => {
                const matchGiornata = parseInt(m.giornata || '0', 10) || 0;
                console.log('Valutando partita:', m.homeTeam, 'vs', m.awayTeam, 
                          'Giornata:', matchGiornata, 
                          'Target:', nextGiornata,
                          'Match:', matchGiornata === nextGiornata);
                return matchGiornata === nextGiornata;
            });

            if (filteredMatches.length === 0) {
                noMatchesMessage.classList.remove('hidden');
                noMatchesMessage.textContent = `Nessuna partita aperta per la Giornata ${nextGiornata} (Prossima giornata di scommesse).`;
                stakeButton.disabled = true;
                stakeButton.textContent = "Nessuna partita aperta";
                listContainer.innerHTML = ''; // Pulisci il contenitore
                return;
            }

            noMatchesMessage.classList.add('hidden');

            // Costruzione DOM con fragment
            const frag = document.createDocumentFragment();
            
            // Aggiungi messaggio se le scommesse sono gi√† state piazzate
            if (hasConfirmedBets) {
                // Calcola vincita potenziale per scommesse salvate
                let totalStakeSaved = 0;
                let potentialWinSaved = 0;
                
                filteredMatches.forEach(match => {
                    const userBet = match.userBet || {};
                    if (userBet.stake > 0 && userBet.prediction && userBet.odds) {
                        totalStakeSaved += userBet.stake;
                        potentialWinSaved += userBet.stake * parseFloat(userBet.odds);
                    }
                });
                
                const profittoSaved = potentialWinSaved - totalStakeSaved;
                
                const alertDiv = document.createElement('div');
                alertDiv.className = 'bg-yellow-900 border-l-4 border-yellow-500 text-yellow-200 p-4 mb-4 rounded';
                alertDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <svg class="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                            </svg>
                            <p class="font-semibold">Scommesse gi√† piazzate per questa giornata</p>
                        </div>
                        <div class="text-right">
                            <p class="text-xs">Vincita Potenziale</p>
                            <p class="text-xl font-bold text-green-300">${potentialWinSaved.toFixed(2)} Cr</p>
                            <p class="text-xs">(Profitto: <span class="font-semibold ${profittoSaved >= 0 ? 'text-green-300' : 'text-red-300'}">${profittoSaved >= 0 ? '+' : ''}${profittoSaved.toFixed(2)} Cr</span>)</p>
                        </div>
                    </div>
                `;
                frag.appendChild(alertDiv);
            }
            
            const title = document.createElement('div');
            title.innerHTML = `<h3 class="text-xl font-bold text-yellow-500 mb-4">Scommetti su: Giornata ${nextGiornata} (${filteredMatches.length} Partite)</h3>`;
            frag.appendChild(title);

            filteredMatches.sort((a, b) => new Date(a.date) - new Date(b.date));

            filteredMatches.forEach(match => {
                const userBet = match.userBet || { prediction: null, stake: 0 };
                if (userBet.prediction) currentPredictions[match.id] = userBet.prediction;

                const matchCard = document.createElement('div');
                matchCard.id = `match-${match.id}`;
                matchCard.className = 'card p-4 mb-4';

                let stakeStatusText;
                if (userBet.stake > 0) {
                    const potentialWinForMatch = userBet.stake * parseFloat(userBet.odds || 1);
                    const profitForMatch = potentialWinForMatch - userBet.stake;
                    stakeStatusText = `
                        <span class="font-bold text-yellow-300">SALVATA: ${userBet.prediction} @ ${userBet.odds}</span>
                        <span class="text-sm text-gray-400"> | Puntata: ${userBet.stake.toFixed(2)} Cr</span>
                        <span class="text-sm text-green-400"> | Vincita potenziale: ${potentialWinForMatch.toFixed(2)} Cr (${profitForMatch >= 0 ? '+' : ''}${profitForMatch.toFixed(2)} Cr)</span>
                    `;
                } else {
                    stakeStatusText = `Nessuna`;
                }

                matchCard.innerHTML = `
                    <div class="flex justify-between items-center mb-3 border-b border-gray-800 pb-2">
                        <div class="flex items-center space-x-3">
                            <img src="${getTeamLogo(match.homeTeam)}" alt="${match.homeTeam}" class="w-10 h-10 object-contain rounded" onerror="this.style.display='none'">
                            <h3 class="text-xl font-bold text-green-300">${match.homeTeam} vs ${match.awayTeam}</h3>
                            <img src="${getTeamLogo(match.awayTeam)}" alt="${match.awayTeam}" class="w-10 h-10 object-contain rounded" onerror="this.style.display='none'">
                        </div>
                        <span class="text-sm text-gray-400">${match.date}</span>
                    </div>
                    <p class="mb-4 text-sm text-gray-400">Scommessa: ${stakeStatusText}</p>
                    <div class="grid grid-cols-3 gap-3">
                        ${renderBetOption(match, '1', userBet, hasConfirmedBets)}
                        ${renderBetOption(match, 'X', userBet, hasConfirmedBets)}
                        ${renderBetOption(match, '2', userBet, hasConfirmedBets)}
                    </div>
                `;
                frag.appendChild(matchCard);
            });

            listContainer.appendChild(frag);
            updateGiornataBetButton();
        };
        
        const renderBetOption = (match, prediction, userBet, hasConfirmedBets) => {
            const isSavedBet = userBet.prediction === prediction;
            const isLocalBet = currentPredictions[match.id] === prediction;
            const hasSavedBet = userBet.stake > 0; // C'√® gi√† una scommessa salvata per questo match

            let betClass = '';
            let pointerEvents = '';
            let opacity = '';
            
            // Se ci sono scommesse confermate per la giornata, blocca tutti i click
            if (hasConfirmedBets) {
                if (isSavedBet) {
                    // Se la scommessa √® salvata in Firestore
                    betClass = 'saved-bet';
                } else {
                    // Tutte le altre opzioni sono disabilitate
                    opacity = 'opacity-50';
                }
                pointerEvents = 'pointer-events-none';
            } else {
                // Logica normale quando non ci sono scommesse confermate
                if (isLocalBet) {
                    // Se √® solo la selezione locale temporanea (non salvata)
                    betClass = 'local-selected';
                }
            }
            
            const clickHandler = hasConfirmedBets ? '' : `onclick="recordPrediction('${match.id}', '${prediction}')"`;
            
            return `
                <div ${clickHandler}
                     data-match-id="${match.id}" 
                     data-prediction="${prediction}"
                     class="bet-option ${betClass} ${pointerEvents} ${opacity} p-3 text-center bg-gray-800 rounded-lg cursor-${hasConfirmedBets ? 'not-allowed' : 'pointer'}">
                    <p class="text-lg font-semibold">${prediction}</p>
                    <p class="text-xs text-gray-400">Quota: ${match.odds[prediction]}</p>
                </div>
            `;
        };

        // Renderizza le scommesse gi√† piazzate dall'utente
        const renderPlacedBets = (userBets) => {
            const listContainer = document.getElementById('user-placed-bets-list');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            if (!userBets || userBets.length === 0) {
                listContainer.innerHTML = '<p class="text-gray-500 text-center">Non hai ancora piazzato nessuna scommessa per le prossime giornate.</p>';
                return;
            }

            // Raggruppa per giornata
            const betsByGiornata = userBets.reduce((acc, bet) => {
                const giornata = bet.giornata || 'Sconosciuta';
                if (!acc[giornata]) acc[giornata] = [];
                acc[giornata].push(bet);
                return acc;
            }, {});

            const sortedGiornate = Object.keys(betsByGiornata).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));

            sortedGiornate.forEach(giornata => {
                const giornataHeader = document.createElement('h4');
                giornataHeader.className = 'text-xl font-bold text-yellow-500 mt-4 mb-3 border-b border-gray-700 pb-2';
                giornataHeader.textContent = `Giornata ${giornata}`;
                listContainer.appendChild(giornataHeader);

                betsByGiornata[giornata].forEach(bet => {
                    const betCard = document.createElement('div');
                    betCard.className = 'card p-4 mb-3 border-l-4 border-blue-500';
                    
                    let betHTML = `
                        <div class="mb-3">
                            <div class="flex justify-between items-center">
                                <h5 class="font-semibold text-green-300 text-lg">Scommessa Giornata ${giornata}</h5>
                                <div class="text-right">
                                    <div class="text-sm text-gray-400">
                                        Puntata: <span class="font-bold text-blue-400">${bet.stake || 0}</span> crediti
                                    </div>
                                    <div class="text-sm text-gray-400">
                                        Quota Totale: <span class="font-bold text-blue-400">${bet.quotaTotale ? bet.quotaTotale.toFixed(2) : '-'}</span>
                                    </div>
                                    <div class="text-sm text-gray-400">
                                        Vincita Potenziale: <span class="font-bold text-green-400">${bet.potentialWinnings ? bet.potentialWinnings.toFixed(2) : '-'}</span> crediti
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Mostra i pronostici
                    if (bet.predictions && bet.predictions.length > 0) {
                        betHTML += '<div class="space-y-2">';
                        bet.predictions.forEach(pred => {
                            betHTML += `
                                <div class="p-2 bg-gray-800 rounded-lg border border-gray-700">
                                    <div class="flex justify-between items-center">
                                        <div class="flex-1">
                                            <div class="font-semibold">${pred.homeTeam || '-'} vs ${pred.awayTeam || '-'}</div>
                                            <div class="text-sm text-gray-400">
                                                Pronostico: <span class="font-bold text-blue-400">${pred.prediction}</span> 
                                                (Quota: ${pred.odds ? parseFloat(pred.odds).toFixed(2) : '-'})
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                        betHTML += '</div>';
                    }
                    
                    betCard.innerHTML = betHTML;
                    listContainer.appendChild(betCard);
                });
            });
        };

        // Funzione per impostare/reimpostare il listener delle scommesse admin
        const setupAdminBetsListener = (giornataNum, allUsers) => {
            // Disiscrivi il listener precedente se esiste
            if (adminBetsUnsubscribe) {
                try { adminBetsUnsubscribe(); } catch (e) { /* ignore */ }
                adminBetsUnsubscribe = null;
            }
     
            const adminBetsList = document.getElementById('admin-bets-list');
            if (!isUserAdmin) {
                if (adminBetsList) adminBetsList.innerHTML = '<p class="text-gray-500">Accesso non autorizzato.</p>';
                return;
            }

            // Carica TUTTE le scommesse, non solo quelle della giornata corrente
            // Il filtro pending/settled/all viene gestito da renderAdminBetsList
            adminBetsUnsubscribe = addUnsubscribe(
                onSnapshot(getGiornataBetsCollectionRef(), (snapshot) => {
                    const allCurrentBets = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                    console.log('Scommesse caricate per admin:', allCurrentBets.length);
                    renderAdminBetsList(allCurrentBets, allUsers || [], currentBetsFilter);
                }, (error) => console.error("Errore onSnapshot Bets (Admin):", error))
            );
        };

        // Renderizza la lista degli utenti per l'admin
        const renderAdminUsersList = (users) => {
            const listContainer = document.getElementById('admin-users-list');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            if (!users || users.length === 0) {
                listContainer.innerHTML = '<div class="text-center text-gray-500 py-4">Nessun utente registrato.</div>';
                return;
            }

            users.forEach(user => {
                const row = document.createElement('div');
                row.className = 'flex items-center justify-between p-2 bg-gray-900 rounded mb-2';
                row.innerHTML = `
                    <div class="text-sm text-gray-300">${user.email || user.id}</div>
                    <div class="flex items-center space-x-2">
                        <label class="text-sm text-gray-400">Admin: <input type="checkbox" id="isAdmin-${user.id}" ${user.isAdmin ? 'checked' : ''}></label>
                        <input type="number" id="credits-${user.id}" value="${user.credits || 0}" class="bg-gray-800 text-sm p-1 rounded w-24" />
                        <button onclick="updateUserPermissionsAndCredits('${user.id}')" class="btn-secondary px-3 py-1 text-sm">Salva</button>
                    </div>
                `;
                listContainer.appendChild(row);
            });
        };

        // Aggiorna il nome visualizzato di un utente (admin)
        window.updateUserPermissionsAndCredits = async (uid) => {
            if (!isUserAdmin) return;
            const isAdmin = document.getElementById(`isAdmin-${uid}`).checked;
            const credits = parseInt(document.getElementById(`credits-${uid}`).value, 10);

            if (isNaN(credits)) {
                messageBox("I crediti devono essere un numero.");
                return;
            }

            try {
                await updateDoc(doc(getUsersCollectionRef(), uid), { 
                    isAdmin: isAdmin,
                    credits: credits
                });
                messageBox("Permessi e crediti utente aggiornati.");
            } catch (error) {
                console.error("Errore aggiornamento permessi utente:", error);
                messageBox("Errore durante l'aggiornamento dei permessi e crediti utente.");
            }
        };

        // --- GESTIONE ORARI GIORNATE (ADMIN) ---
        
        // Carica e renderizza gli orari delle giornate per l'admin
        window.loadSchedulesForAdmin = async () => {
            if (!isUserAdmin) return;
            
            try {
                // Ricarica la cache
                scheduleCache = null;
                await loadAllSchedules();
                
                const tbody = document.getElementById('schedules-table-body');
                tbody.innerHTML = '';
                
                // Genera righe per tutte le 36 giornate del fantacalcio (Serie A giornate 3-38)
                for (let g = 1; g <= 36; g++) {
                    const schedule = await getGiornataSchedule(g);
                    const deadline = new Date(`${schedule.date}T${schedule.time}:00`);
                    const now = new Date();
                    const isPast = now >= deadline;
                    const isUpcoming = !isPast && (deadline - now) < 7 * 24 * 60 * 60 * 1000; // Prossimi 7 giorni
                    
                    const row = document.createElement('tr');
                    row.className = isPast ? 'bg-gray-800/50 opacity-60' : isUpcoming ? 'bg-yellow-900/20' : '';
                    
                    // Calcola la giornata Serie A corrispondente
                    const serieAGiornata = g + 2;
                    
                    // Calcola countdown
                    let countdownText = '';
                    if (isPast) {
                        countdownText = '<span class="text-gray-500 text-xs">Passata</span>';
                    } else {
                        const diff = deadline - now;
                        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        if (days > 0) {
                            countdownText = `<span class="text-blue-400 text-xs">${days}g ${hours}h</span>`;
                        } else {
                            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                            countdownText = `<span class="text-yellow-400 font-bold text-xs">${hours}h ${minutes}m</span>`;
                        }
                    }
                    
                    row.innerHTML = `
                        <td class="px-3 py-2 font-bold ${isUpcoming ? 'text-yellow-400' : ''}">${g}</td>
                        <td class="px-3 py-2 text-gray-400 text-xs">${serieAGiornata}</td>
                        <td class="px-3 py-2">
                            <input type="date" 
                                   id="schedule-date-${g}" 
                                   value="${schedule.date}" 
                                   class="bg-gray-800 text-white px-2 py-1 rounded text-sm w-full"
                                   ${isPast ? 'disabled' : ''}>
                        </td>
                        <td class="px-3 py-2">
                            <input type="time" 
                                   id="schedule-time-${g}" 
                                   value="${schedule.time}" 
                                   class="bg-gray-800 text-white px-2 py-1 rounded text-sm w-full"
                                   ${isPast ? 'disabled' : ''}>
                        </td>
                        <td class="px-3 py-2 text-center">
                            <input type="checkbox" 
                                   id="schedule-confirmed-${g}" 
                                   ${schedule.confirmed ? 'checked' : ''}
                                   class="w-4 h-4"
                                   ${isPast ? 'disabled' : ''}>
                        </td>
                        <td class="px-3 py-2">
                            <input type="text" 
                                   id="schedule-notes-${g}" 
                                   value="${schedule.notes || ''}" 
                                   placeholder="Es: Anticipo venerd√¨ ore 20:45"
                                   class="bg-gray-800 text-white px-2 py-1 rounded text-xs w-full"
                                   ${isPast ? 'disabled' : ''}>
                        </td>
                        <td class="px-3 py-2 text-center">
                            ${countdownText}
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                }
                
                messageBox("Orari caricati correttamente.");
            } catch (error) {
                console.error('Errore caricamento schedules:', error);
                messageBox("Errore nel caricamento degli orari: " + error.message);
            }
        };
        
        // Salva tutti gli orari modificati
        window.saveAllSchedules = async () => {
            if (!isUserAdmin) return;
            
            if (!confirm("Salvare tutte le modifiche agli orari delle giornate?")) {
                return;
            }
            
            try {
                const batch = writeBatch(db);
                
                // Salva solo le 36 giornate del fantacalcio (Serie A giornate 3-38)
                for (let g = 1; g <= 36; g++) {
                    const dateInput = document.getElementById(`schedule-date-${g}`);
                    const timeInput = document.getElementById(`schedule-time-${g}`);
                    const confirmedInput = document.getElementById(`schedule-confirmed-${g}`);
                    const notesInput = document.getElementById(`schedule-notes-${g}`);
                    
                    if (!dateInput || !timeInput || !confirmedInput || !notesInput) continue;
                    if (dateInput.disabled) continue; // Salta le giornate passate
                    
                    const scheduleData = {
                        giornata: g.toString(),
                        date: dateInput.value,
                        time: timeInput.value,
                        confirmed: confirmedInput.checked,
                        notes: notesInput.value.trim()
                    };
                    
                    const docRef = doc(getScheduleCollectionRef(), `giornata_${g}`);
                    batch.set(docRef, scheduleData, { merge: true });
                }
                
                await batch.commit();
                
                // Ricarica la cache
                scheduleCache = null;
                await loadAllSchedules();
                
                messageBox("‚úÖ Tutti gli orari sono stati salvati con successo!");
                
                // Ricarica la vista
                await loadSchedulesForAdmin();
            } catch (error) {
                console.error('Errore salvataggio schedules:', error);
                messageBox("Errore nel salvataggio degli orari: " + error.message);
            }
        };

        // Renderizza la lista delle scommesse per l'admin
        let currentBetsFilter = 'pending'; // Default: mostra solo quelle da liquidare
        
        window.renderAdminBetsFilter = async (filter) => {
            currentBetsFilter = filter;
            
            // Aggiorna pulsanti attivi
            document.getElementById('filter-all').className = filter === 'all' ? 'btn-primary' : 'btn-secondary';
            document.getElementById('filter-pending').className = filter === 'pending' ? 'btn-primary' : 'btn-secondary';
            document.getElementById('filter-settled').className = filter === 'settled' ? 'btn-primary' : 'btn-secondary';
            
            // Ricarica la lista
            const snapshot = await getDocs(getGiornataBetsCollectionRef());
            const allBets = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const usersSnapshot = await getDocs(getUsersCollectionRef());
            const allUsers = usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            renderAdminBetsList(allBets, allUsers, filter);
        };
        
        const renderAdminBetsList = (bets, users, filter = 'pending') => {
            console.log('renderAdminBetsList chiamato:', {
                totaleBets: bets?.length,
                filtro: filter,
                users: users?.length
            });
            
            const listContainer = document.getElementById('admin-bets-list');
            if (!listContainer) {
                console.error('Container admin-bets-list non trovato!');
                return;
            }
            listContainer.innerHTML = '';

            if (!bets || bets.length === 0) {
                listContainer.innerHTML = '<p class="text-gray-500">Nessuna scommessa trovata.</p>';
                return;
            }

            // Filtra le scommesse in base al filtro selezionato
            let filteredBets = bets;
            if (filter === 'pending') {
                filteredBets = bets.filter(b => !b.settled);
            } else if (filter === 'settled') {
                filteredBets = bets.filter(b => b.settled);
            }

            console.log('Scommesse dopo filtro:', {
                filtro: filter,
                totale: bets.length,
                filtrate: filteredBets.length,
                dettaglio: filteredBets.map(b => ({
                    giornata: b.giornata,
                    userId: b.userId,
                    stake: b.stake,
                    settled: b.settled,
                    predictions: b.predictions?.length
                }))
            });

            if (filteredBets.length === 0) {
                listContainer.innerHTML = `<p class="text-gray-500">Nessuna scommessa ${filter === 'pending' ? 'da liquidare' : filter === 'settled' ? 'liquidata' : ''} trovata.</p>`;
                return;
            }

            // Raggruppa le scommesse per giornata
            const betsByGiornata = filteredBets.reduce((acc, bet) => {
                const g = bet.giornata || 'Sconosciuta';
                if (!acc[g]) acc[g] = [];
                acc[g].push(bet);
                return acc;
            }, {});

            console.log('Scommesse raggruppate per giornata:', betsByGiornata);

            const userMap = (users || []).reduce((m, u) => { 
                m[u.uid || u.id] = u.displayName || u.email || u.id; 
                return m; 
            }, {});
            
            console.log('Mappa utenti:', userMap);

            const sortedGiornate = Object.keys(betsByGiornata).sort((a,b) => parseInt(a,10) - parseInt(b,10));

            console.log('Rendering giornate:', sortedGiornate);

            sortedGiornate.forEach(g => {
                const header = document.createElement('h4');
                header.className = 'text-lg font-bold text-yellow-500 mt-4 mb-2';
                header.textContent = `Giornata ${g}`;
                listContainer.appendChild(header);

                const betsInG = betsByGiornata[g];
                
                console.log(`Rendering ${betsInG.length} scommesse per Giornata ${g}:`, betsInG);
                
                betsInG.forEach(bet => {
                    const userName = userMap[bet.userId] || bet.userId;
                    console.log('Rendering scommessa:', {
                        giornata: g,
                        utente: userName,
                        stake: bet.stake,
                        predictions: bet.predictions?.length,
                        settled: bet.settled
                    });
                    
                    const userCard = document.createElement('div');
                    userCard.className = `card p-4 mb-3 ${bet.settled ? (bet.isWinning ? 'border-l-4 border-green-500' : 'border-l-4 border-red-500') : 'border-l-4 border-yellow-500'}`;
                    
                    let betHTML = `
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <h5 class="font-semibold text-green-300 text-lg">${userName}</h5>
                                <div class="text-sm text-gray-400">
                                    Puntata: <span class="font-bold text-blue-400">${bet.stake || 0}</span> crediti | 
                                    Quota Totale: <span class="font-bold text-blue-400">${bet.quotaTotale ? bet.quotaTotale.toFixed(2) : '-'}</span>
                                </div>
                            </div>
                            <div class="text-right">
                                ${bet.settled ? `
                                    <div class="text-sm">
                                        <div class="${bet.isWinning ? 'text-green-400' : 'text-red-400'} font-bold text-lg">
                                            ${bet.isWinning ? '‚úì VINCENTE' : '‚úó PERDENTE'}
                                        </div>
                                        <div class="text-gray-400">
                                            Vincita: <span class="${bet.isWinning ? 'text-green-400' : 'text-red-400'} font-bold">${bet.winnings ? bet.winnings.toFixed(2) : '0.00'}</span>
                                        </div>
                                        <div class="text-xs text-gray-500">
                                            Liquidata il: ${bet.settledAt ? new Date(bet.settledAt).toLocaleString('it-IT') : '-'}
                                        </div>
                                    </div>
                                ` : `
                                    <div class="text-yellow-400 font-bold">DA LIQUIDARE</div>
                                `}
                            </div>
                        </div>
                    `;

                    // Mostra i pronostici
                    if (bet.predictions && bet.predictions.length > 0) {
                        betHTML += '<div class="space-y-2">';
                        bet.predictions.forEach(pred => {
                            let resultClass = '';
                            let resultIcon = '';
                            
                            if (bet.settled && bet.detailedResults) {
                                const matchResult = bet.detailedResults.find(r => 
                                    r.match === `${pred.homeTeam} vs ${pred.awayTeam}`
                                );
                                if (matchResult) {
                                    resultClass = matchResult.correct ? 'bg-green-900/30 border-green-600' : 'bg-red-900/30 border-red-600';
                                    resultIcon = matchResult.correct ? 
                                        `<span class="text-green-400 font-bold">‚úì</span> Risultato: ${matchResult.actual}` : 
                                        `<span class="text-red-400 font-bold">‚úó</span> Risultato: ${matchResult.actual}`;
                                }
                            }
                            
                            betHTML += `
                                <div class="p-2 bg-gray-800 rounded-lg border ${resultClass || 'border-gray-700'}">
                                    <div class="flex justify-between items-center">
                                        <div class="flex-1">
                                            <div class="font-semibold">${pred.homeTeam || '-'} vs ${pred.awayTeam || '-'}</div>
                                            <div class="text-sm text-gray-400">
                                                Pronostico: <span class="font-bold text-blue-400">${pred.prediction}</span> 
                                                (Quota: ${pred.odds ? parseFloat(pred.odds).toFixed(2) : '-'})
                                            </div>
                                        </div>
                                        ${resultIcon ? `<div class="text-sm ml-4">${resultIcon}</div>` : ''}
                                    </div>
                                </div>
                            `;
                        });
                        betHTML += '</div>';
                    }

                    userCard.innerHTML = betHTML;
                    listContainer.appendChild(userCard);
                });
            });
        };

        // Aggiorna la scommessa di un utente (admin)
        window.updateUserBet = async (betId) => {
            if (!isUserAdmin) return;
            const select = document.getElementById(`bet-edit-${betId}`);
            if (!select) return;
            const newPrediction = select.value;
            try {
                const betDocRef = doc(getGiornataBetsCollectionRef(), betId);
                await updateDoc(betDocRef, { prediction: newPrediction });
                messageBox("Pronostico aggiornato con successo.");
            } catch (error) {
                console.error("Errore aggiornamento scommessa:", error);
                messageBox("Errore durante l'aggiornamento della scommessa.");
            }
        };

        // --- NUOVE FUNZIONI PER PROFILO UTENTE ---

        // Listener per il profilo dell'utente corrente
        const setupUserProfileListener = async (uid) => {
            if (!uid) return;
            
            try {
                const userDocRef = doc(getUsersCollectionRef(), uid);
                // Prima controlla se il documento esiste
                const docSnap = await getDoc(userDocRef);
                
                if (!docSnap.exists()) {
                    // Se il documento non esiste, crealo con valori di default
                    const isDefaultAdmin = ADMIN_USER_IDS.includes(uid);
                    const defaultUserData = {
                        email: auth.currentUser?.email,
                        displayName: auth.currentUser?.email?.split('@')[0] || 'Utente',
                        credits: 100,
                        isAdmin: isDefaultAdmin,
                        createdAt: new Date().toISOString()
                    };
                    
                    await setDoc(userDocRef, defaultUserData);
                    console.log("Creato nuovo profilo utente per:", uid);
                }
                
                // Ora imposta il listener
                addUnsubscribe(
                    onSnapshot(userDocRef, (docSnapshot) => {
                        if (docSnapshot.exists()) {
                            currentUserProfile = { id: docSnapshot.id, ...docSnapshot.data() };
                            userCredits = currentUserProfile.credits || 100; // Aggiorna i crediti globali
                            isUserAdmin = currentUserProfile.isAdmin || false; // Aggiorna lo stato admin
                            updateUserInfoDisplay(); // Aggiorna la UI con il nuovo nome
                            if (currentView === 'profile') {
                                renderProfileArea(); // Ricarica la sezione profilo se √® aperta
                            }
                        } else {
                            console.warn("Documento utente non trovato per UID:", uid);
                            currentUserProfile = null;
                        }
                    }, (error) => {
                        console.error("Errore onSnapshot User Profile:", error);
                        messageBox("Errore nel caricamento del profilo utente. Prova a ricaricare la pagina.");
                    })
                );
                
            } catch (error) {
                console.error("Errore setup profilo utente:", error);
                messageBox("Errore nella configurazione del profilo utente. Contatta l'amministratore.");
            }
        };

        // Renderizza la sezione Profilo
        const renderProfileArea = () => {
            const emailInput = document.getElementById('profile-email');
            const displayNameInput = document.getElementById('profile-display-name');
            if (currentUserProfile) {
                emailInput.value = currentUserProfile.email;
                
                // Se non c'√® un displayName, proponi un default basato sull'email
                if (!currentUserProfile.displayName || currentUserProfile.displayName === '') {
                    const emailUsername = currentUserProfile.email.split('@')[0];
                    displayNameInput.value = '@' + emailUsername;
                } else {
                    displayNameInput.value = currentUserProfile.displayName;
                }
            }
            document.getElementById('profile-area').classList.remove('hidden');
        };

        // Salva le modifiche al profilo utente
        window.saveUserProfile = async () => { // Corretto: esposto a window
            const newDisplayName = document.getElementById('profile-display-name').value.trim();
            if (!newDisplayName) {
                messageBox("Il nome visualizzato non pu√≤ essere vuoto.");
                return;
            }
            await updateDoc(doc(getUsersCollectionRef(), userId), { displayName: newDisplayName });
            messageBox("Profilo aggiornato con successo!");
        };

        // --- Inizializzazione Listener ---

        const setupListeners = () => {
            console.log('Inizializzazione listeners...');
            
            // Prima rimuovi eventuali listener esistenti
            removeAllListeners();
            
            // Listener per le Squadre
            addUnsubscribe(
                onSnapshot(getTeamCollectionRef(), (snapshot) => {
                    console.log('Snapshot Teams ricevuto:', {
                        numeroTeams: snapshot.docs.length,
                        teams: snapshot.docs.map(doc => doc.data().name)
                    });
                    
                    allTeams = snapshot.docs.map(doc => doc.data().name).filter(name => name); 
                    updateTeamSelects(allTeams);
                }, (error) => console.error("Errore onSnapshot Teams:", error))
            );
            
            // Listener per i Risultati Storici
            addUnsubscribe(
                onSnapshot(getResultsCollectionRef(), (snapshot) => {
                    allResults = snapshot.docs.map(doc => doc.data());
                    renderHistoricResults(allResults);
                    renderStandings(); // Aggiorna la classifica quando cambiano i risultati
                    renderStatistics(); // Aggiorna le statistiche quando cambiano i risultati
                    renderStandingsTrend(); // Aggiorna l'andamento della classifica
                    // Se la vista scommesse √® aperta, ricalcola la prossima giornata in base ai risultati
                    if (currentView === 'betting' && allMatches && allMatches.length > 0) {
                        const lastCompleted = determineLastCompletedGiornata();
                        const nextG = lastCompleted + 1;
                        console.log('onSnapshot(Results): re-render betting con giornata', nextG);
                        renderOpenMatches(allMatches, nextG);
                    }
                }, (error) => console.error("Errore onSnapshot Results:", error))
            );
            
            // Listener per TUTTE le Partite (Aperte e Chiuse)
            addUnsubscribe(
                onSnapshot(getMatchesCollectionRef(), async (snapshot) => {
                    try {
                        console.log('Snapshot delle partite ricevuto:', {
                            numeroDoc: snapshot.docs.length,
                            docs: snapshot.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data()
                            }))
                        });

                        allMatches = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        console.log('Partite caricate in allMatches:', allMatches.length);
                        
                        // 1. Aggiorna la tendina di chiusura Admin
                        updateMatchToCloseSelect(allMatches);
                

                // Determina l'ultima giornata con risultati
                console.log('Analisi giornate dalle partite:', {
                    totalePartite: allMatches.length,
                    statoPartite: allMatches.map(m => ({
                        partita: `${m.homeTeam} vs ${m.awayTeam}`,
                        giornata: m.giornata,
                        status: m.status,
                        result: m.result
                    }))
                });
                
                const partiteChiuse = allMatches.filter(m => m.status === 'closed' && m.result);
                console.log('Partite chiuse trovate:', {
                    numero: partiteChiuse.length,
                    dettaglio: partiteChiuse.map(m => ({
                        partita: `${m.homeTeam} vs ${m.awayTeam}`,
                        giornata: m.giornata,
                        status: m.status,
                        result: m.result
                    }))
                });
                
                let giornatePresenti = new Set(allMatches.map(m => parseInt(m.giornata || '0', 10)));
                console.log('Giornate presenti nel sistema:', Array.from(giornatePresenti).sort());

                // Usa anche i risultati storici per determinare l'ultima giornata completata
                const lastCompletedGiornata = determineLastCompletedGiornata();
                console.log('Ultima giornata completata (combinata):', lastCompletedGiornata);

                // La prossima giornata √® quella successiva all'ultima completata
                let newNextGiornata = lastCompletedGiornata + 1;
                console.log('Prossima giornata disponibile:', newNextGiornata);
                
                // Filtra le partite aperte solo della prossima giornata
                console.log('Inizio filtro partite aperte. Stato attuale:', {
                    totalePartite: allMatches.length,
                    prossimaGiornata: newNextGiornata,
                    partitePerStato: allMatches.reduce((acc, m) => {
                        acc[m.status || 'undefined'] = (acc[m.status || 'undefined'] || 0) + 1;
                        return acc;
                    }, {})
                });
                
                let openMatchesData = allMatches.filter(m => {
                    const isOpen = m.status === 'open' || !m.status;
                    const giornataNum = parseInt(m.giornata || '0', 10);
                    const isNextGiornata = giornataNum === newNextGiornata;
                    
                    console.log('Valutazione partita:', {
                        partita: `${m.homeTeam} vs ${m.awayTeam}`,
                        giornata: giornataNum,
                        status: m.status,
                        isOpen,
                        isNextGiornata,
                        prossimaGiornata: newNextGiornata,
                        risultatoFiltro: isOpen && isNextGiornata
                    });
                    
                    console.log('Analisi partita:', {
                        partita: `${m.homeTeam} vs ${m.awayTeam}`,
                        giornata: giornataNum,
                        status: m.status,
                        isOpen: isOpen,
                        isNextGiornata: isNextGiornata,
                        odds: m.odds
                    });
                    
                    return isOpen && isNextGiornata;
                });
                
                // Se il numero della prossima giornata √® cambiato, aggiorna e reimposta il listener delle scommesse admin
                if (newNextGiornata !== nextGiornataNumber) {
                    nextGiornataNumber = newNextGiornata;
                    if (isUserAdmin) {
                        setupAdminBetsListener(nextGiornataNumber, allUsersForAdmin); // Passa la lista utenti
                    }
                }
                
                if (nextGiornataNumber === 0) { // Nessuna giornata aperta valida
                    openMatchesData = []; // Nessuna partita da mostrare
                }

                // 3. FILTRA le partite per includere solo la PROSSIMA GIORNATA
                openMatchesData = openMatchesData.filter(m => parseInt(m.giornata) === newNextGiornata);
                console.log('Partite filtrate per la prossima giornata:', {
                    giornata: newNextGiornata,
                    partiteTrovate: openMatchesData.length,
                    dettaglio: openMatchesData.map(m => ({
                        partita: `${m.homeTeam} vs ${m.awayTeam}`,
                        giornata: m.giornata,
                        status: m.status
                    }))
                });

                // 4. Recupera la scommessa dell'utente per questa giornata (formato nuovo: una scommessa per giornata)
                let userGiornataBet = null;
                if (userId && newNextGiornata) {
                    const betDocRef = doc(getGiornataBetsCollectionRef(), `${userId}_giornata_${newNextGiornata}`);
                    const betSnapshot = await getDoc(betDocRef);
                    if (betSnapshot.exists()) {
                        userGiornataBet = betSnapshot.data();
                        console.log('Scommessa trovata per giornata', newNextGiornata, ':', userGiornataBet);
                    }
                }
                
                // Assegna la scommessa a tutte le partite per compatibilit√† con renderOpenMatches
                openMatches = openMatchesData.map(match => {
                    // Se esiste una scommessa per la giornata, marca la partita come "bet placed"
                    if (userGiornataBet) {
                        // Trova la predizione per questa partita specifica
                        const prediction = userGiornataBet.predictions?.find(p => p.matchId === match.id);
                        match.userBet = {
                            prediction: prediction?.prediction || null,
                            stake: userGiornataBet.stake || 0,
                            odds: prediction?.odds || 0
                        };
                    } else {
                        match.userBet = { prediction: null, stake: 0 };
                    }
                    return match;
                });
                
                        // 5. Renderizza solo la prossima giornata
                        renderOpenMatches(openMatches, nextGiornataNumber);
                    } catch (error) {
                        console.error("Errore nell'elaborazione del match snapshot:", error);
                    }
                }, (error) => console.error("Errore onSnapshot Matches:", error)));

            // Listener per le scommesse piazzate dall'utente
            const qUserBets = query(getGiornataBetsCollectionRef(), where('userId', '==', userId));
            addUnsubscribe(
                onSnapshot(qUserBets, (snapshot) => {
                    userPlacedBets = snapshot.docs.map(doc => doc.data());
                    renderPlacedBets(userPlacedBets);
                }, (error) => console.error("Errore onSnapshot User Placed Bets:", error))
            );

            // Listener per Admin: Utenti e Scommesse
            if (isUserAdmin) {
                // Listener per tutti gli utenti
                addUnsubscribe(
                    onSnapshot(getUsersCollectionRef(), (snapshot) => {
                        allUsersForAdmin = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        renderAdminUsersList(allUsersForAdmin);
                        // Avvia sempre il listener delle scommesse admin, indipendentemente da nextGiornataNumber
                        setupAdminBetsListener(nextGiornataNumber, allUsersForAdmin);
                    }, (error) => console.error("Errore onSnapshot Users:", error))
                );
            }
        };

        // --- Effetto Halloween INTENSO (30 ottobre - 2 novembre 2025) ---
        function initHalloweenEffect() {
            const now = new Date();
            const currentDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const startDate = new Date(2025, 9, 30); // 30 ottobre 2025 (mese 9 = ottobre)
            const endDate = new Date(2025, 10, 2); // 2 novembre 2025 (mese 10 = novembre)
            
            // Verifica se siamo nel periodo Halloween
            if (currentDate >= startDate && currentDate <= endDate) {
                console.log('üéÉüëªüíÄ HALLOWEEN MODE ACTIVATED! üíÄüëªüéÉ');
                const overlay = document.getElementById('halloween-overlay');
                if (!overlay) return;
                
                // Array di emoji Halloween
                const halloweenEmojis = ['üéÉ', 'üëª', 'üíÄ', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶á', 'üßõ', 'üßü', '‚ò†Ô∏è', 'ü™¶', 'üîÆ', 'üßô'];
                
                // Crea ragnatele negli angoli (pi√π grandi)
                const webTopLeft = document.createElement('div');
                webTopLeft.className = 'web-corner top-left';
                webTopLeft.style.transform = 'scale(1.5)';
                overlay.appendChild(webTopLeft);
                
                const webTopRight = document.createElement('div');
                webTopRight.className = 'web-corner top-right';
                webTopRight.style.transform = 'scale(1.5)';
                overlay.appendChild(webTopRight);
                
                // RAGNI CHE SCENDONO - Molti di pi√π!
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const spider = document.createElement('div');
                        spider.className = 'spider';
                        spider.innerHTML = 'üï∑Ô∏è';
                        spider.style.left = `${Math.random() * 95}%`;
                        spider.style.fontSize = `${Math.random() * 20 + 20}px`;
                        spider.style.animationDelay = `${Math.random() * 3}s`;
                        spider.style.animationDuration = `${Math.random() * 4 + 6}s`;
                        overlay.appendChild(spider);
                        setTimeout(() => spider.remove(), 10000);
                    }, i * 400);
                }
                
                // PIPISTRELLI CHE VOLANO - Un'invasione!
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const bat = document.createElement('div');
                        bat.className = 'bat';
                        bat.innerHTML = 'ü¶á';
                        bat.style.top = `${Math.random() * 80}%`;
                        bat.style.fontSize = `${Math.random() * 15 + 25}px`;
                        bat.style.animationDelay = `${Math.random() * 2}s`;
                        bat.style.animationDuration = `${Math.random() * 3 + 4}s`;
                        overlay.appendChild(bat);
                        setTimeout(() => bat.remove(), 8000);
                    }, i * 300);
                }
                
                // FANTASMI CHE FLUTTUANO
                for (let i = 0; i < 12; i++) {
                    setTimeout(() => {
                        const ghost = document.createElement('div');
                        ghost.className = 'bat';
                        ghost.innerHTML = 'üëª';
                        ghost.style.top = `${Math.random() * 70 + 10}%`;
                        ghost.style.fontSize = `${Math.random() * 20 + 30}px`;
                        ghost.style.animationDelay = `${Math.random() * 1.5}s`;
                        ghost.style.animationDuration = `${Math.random() * 2 + 5}s`;
                        ghost.style.opacity = '0.8';
                        overlay.appendChild(ghost);
                        setTimeout(() => ghost.remove(), 7000);
                    }, i * 500);
                }
                
                // ZUCCHE CHE CADONO
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const pumpkin = document.createElement('div');
                        pumpkin.className = 'spider';
                        pumpkin.innerHTML = 'üéÉ';
                        pumpkin.style.left = `${Math.random() * 90}%`;
                        pumpkin.style.fontSize = `${Math.random() * 25 + 30}px`;
                        pumpkin.style.animationDelay = `${Math.random() * 2}s`;
                        pumpkin.style.animationDuration = `${Math.random() * 3 + 5}s`;
                        overlay.appendChild(pumpkin);
                        setTimeout(() => pumpkin.remove(), 9000);
                    }, i * 600);
                }
                
                // TESCHI E SCHELETRI
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const skull = document.createElement('div');
                        skull.className = 'spider';
                        skull.innerHTML = i % 2 === 0 ? 'üíÄ' : '‚ò†Ô∏è';
                        skull.style.left = `${Math.random() * 90}%`;
                        skull.style.fontSize = `${Math.random() * 20 + 25}px`;
                        skull.style.animationDelay = `${Math.random() * 2.5}s`;
                        skull.style.animationDuration = `${Math.random() * 4 + 6}s`;
                        overlay.appendChild(skull);
                        setTimeout(() => skull.remove(), 10000);
                    }, i * 700);
                }
                
                // RAGNATELE VOLANTI
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const web = document.createElement('div');
                        web.className = 'bat';
                        web.innerHTML = 'üï∏Ô∏è';
                        web.style.top = `${Math.random() * 80}%`;
                        web.style.fontSize = `${Math.random() * 25 + 35}px`;
                        web.style.animationDelay = `${Math.random() * 1}s`;
                        web.style.animationDuration = `${Math.random() * 4 + 5}s`;
                        web.style.opacity = '0.7';
                        overlay.appendChild(web);
                        setTimeout(() => web.remove(), 9000);
                    }, i * 800);
                }
                
                // VAMPIRI E ZOMBIE
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const monster = document.createElement('div');
                        monster.className = 'bat';
                        monster.innerHTML = i % 2 === 0 ? 'ÔøΩ' : 'üßü';
                        monster.style.top = `${Math.random() * 70 + 15}%`;
                        monster.style.fontSize = `${Math.random() * 15 + 35}px`;
                        monster.style.animationDelay = `${Math.random() * 1.5}s`;
                        monster.style.animationDuration = `${Math.random() * 3 + 5}s`;
                        overlay.appendChild(monster);
                        setTimeout(() => monster.remove(), 8000);
                    }, i * 1000);
                }
                
                // EXTRA RANDOM MIX
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const randomElement = document.createElement('div');
                        randomElement.className = Math.random() > 0.5 ? 'bat' : 'spider';
                        randomElement.innerHTML = halloweenEmojis[Math.floor(Math.random() * halloweenEmojis.length)];
                        randomElement.style.left = `${Math.random() * 95}%`;
                        randomElement.style.top = `${Math.random() * 80}%`;
                        randomElement.style.fontSize = `${Math.random() * 20 + 20}px`;
                        randomElement.style.animationDelay = `${Math.random() * 2}s`;
                        randomElement.style.animationDuration = `${Math.random() * 3 + 4}s`;
                        overlay.appendChild(randomElement);
                        setTimeout(() => randomElement.remove(), 8000);
                    }, i * 350);
                }
                
                // Attiva l'overlay
                overlay.classList.add('active');
                
                // Rimuovi tutto dopo 12 secondi
                setTimeout(() => {
                    overlay.style.animation = 'fade-out 2s ease-out';
                    setTimeout(() => {
                        overlay.remove();
                        console.log('üéÉ Happy Halloween! Effetto completato üéÉ');
                    }, 2000);
                }, 12000);
            }
        }

        // --- Inizializzazione ---
        window.onload = () => {
            setupFirebase();
            initHalloweenEffect(); // Attiva effetto Halloween se nel periodo
        };
    </script>
    
    <!-- Footer con info versione -->
    <footer class="bg-gray-900/50 border-t border-gray-800 py-4 mt-8">
        <div class="container mx-auto px-4 text-center">
            <p class="text-xs text-gray-500">
                <span class="font-semibold text-gray-400">FANTABet</span> ‚Ä¢ 
                Versione 2.1 ‚Ä¢ 
                Ultimo aggiornamento: <span class="text-gray-400">31 ottobre 2025</span>
            </p>
            <p class="text-xs text-gray-600 mt-1">
                ¬© 2025 - Gestionale Fantacalcio con Sistema Scommesse
            </p>
        </div>
    </footer>
</body>
</html>
